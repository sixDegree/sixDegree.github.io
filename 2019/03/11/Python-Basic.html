<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Python 基础</title>
  
  <!-- Meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  

  <!-- Feed -->
  
    <link rel="alternative" href="/atom.xml" title="SixDegree" type="application/atom+xml">
  

  <!-- CSS -->
  <link rel="stylesheet" href="/bootstrap/dist/css/bootstrap.css">
  
	
		<link rel="stylesheet" href="/highlight/demo/styles/tomorrow-night-bright.css">
	
    
  
  <link rel="stylesheet" href="/css/fontello.css">
  <link rel="stylesheet" href="/css/style.css">

  <!-- Site Analyse -->
  
	<script>
	var userID='2bbb83cc0f781dd7502e9d5e19661866';
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?"+userID;
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


</head>

<body data-spy="scroll" data-target="#nav-catalog">
  <div id="top-push"></div>
<a href="#top-push" id="go-top">
	<span class="glyphicon glyphicon-chevron-up"></span>
</a>
  <aside id="sidebar">
    <section class="sidebar-header">Catalog</section>
     <nav id="nav-catalog">
        <ol class="sidebar-nav nav"><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-1"><span class="sidebar-nav nav-text">Starter</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-2"><span class="sidebar-nav nav-text">开发环境 (IDE)</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-3"><span class="sidebar-nav nav-text">基础</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-4"><span class="sidebar-nav nav-text">关键字</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-5"><span class="sidebar-nav nav-text">注释</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-6"><span class="sidebar-nav nav-text">输出</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-7"><span class="sidebar-nav nav-text">输入</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-8"><span class="sidebar-nav nav-text">运算符</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-9"><span class="sidebar-nav nav-text">判断语句</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-10"><span class="sidebar-nav nav-text">循环语句</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-11"><span class="sidebar-nav nav-text">异常处理</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-12"><span class="sidebar-nav nav-text">给程序传参</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-13"><span class="sidebar-nav nav-text">测试</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-14"><span class="sidebar-nav nav-text">基础数据类型</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-15"><span class="sidebar-nav nav-text">不可变对象 &amp; 可变对象</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-16"><span class="sidebar-nav nav-text">垃圾回收机制</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-17"><span class="sidebar-nav nav-text">类型转换</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-18"><span class="sidebar-nav nav-text">字符编码</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-19"><span class="sidebar-nav nav-text">整数：进制转换／位运算</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-20"><span class="sidebar-nav nav-text">str,tuple,list,set,dict</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-21"><span class="sidebar-nav nav-text">str</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-22"><span class="sidebar-nav nav-text">tuple</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-23"><span class="sidebar-nav nav-text">list</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-24"><span class="sidebar-nav nav-text">set</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-25"><span class="sidebar-nav nav-text">dict</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-26"><span class="sidebar-nav nav-text">函数</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-27"><span class="sidebar-nav nav-text">作用域</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-28"><span class="sidebar-nav nav-text">函数参数</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-29"><span class="sidebar-nav nav-text">函数返回值</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-30"><span class="sidebar-nav nav-text">高级特性：闭包</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-31"><span class="sidebar-nav nav-text">高级特性: 列表生成式</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-32"><span class="sidebar-nav nav-text">高级特性：生成器(generator)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-33"><span class="sidebar-nav nav-text">高级特性：迭代器(Iterator)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-34"><span class="sidebar-nav nav-text">高级特性：装饰器(decorator)</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-35"><span class="sidebar-nav nav-text">匿名函数</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-36"><span class="sidebar-nav nav-text">内建函数</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-37"><span class="sidebar-nav nav-text">类与实例</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-38"><span class="sidebar-nav nav-text">类成员：属性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-39"><span class="sidebar-nav nav-text">类成员：方法</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-40"><span class="sidebar-nav nav-text">继承与多态</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-41"><span class="sidebar-nav nav-text">高阶：元类metaclass</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-42"><span class="sidebar-nav nav-text">高阶：枚举类Enum</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-43"><span class="sidebar-nav nav-text">高阶：单例模式</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-44"><span class="sidebar-nav nav-text">高阶：内置类属性</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-45"><span class="sidebar-nav nav-text">高阶：定制类</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-46"><span class="sidebar-nav nav-text">模块与包</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-47"><span class="sidebar-nav nav-text">导入</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-48"><span class="sidebar-nav nav-text">自定义库</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-49"><span class="sidebar-nav nav-text">发布/安装包</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-50"><span class="sidebar-nav nav-text">常用标准库</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-51"><span class="sidebar-nav nav-text">常用扩展库</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-52"><span class="sidebar-nav nav-text">文件IO</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-53"><span class="sidebar-nav nav-text">读写文件</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-54"><span class="sidebar-nav nav-text">操作文件／目录</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-55"><span class="sidebar-nav nav-text">多任务</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-56"><span class="sidebar-nav nav-text">进程 Process</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-57"><span class="sidebar-nav nav-text">线程 Thread</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-58"><span class="sidebar-nav nav-text">协程 Coroutine</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-59"><span class="sidebar-nav nav-text">访问数据库</span></a><ol class="sidebar-nav nav-child"><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-60"><span class="sidebar-nav nav-text">SQLite</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-61"><span class="sidebar-nav nav-text">MySQL</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-62"><span class="sidebar-nav nav-text">Redis</span></a></li><li class="sidebar-nav nav-item sidebar-nav nav-level-3"><a class="sidebar-nav nav-link" href="#header-63"><span class="sidebar-nav nav-text">MongoDB</span></a></li></ol></li><li class="sidebar-nav nav-item sidebar-nav nav-level-2"><a class="sidebar-nav nav-link" href="#header-64"><span class="sidebar-nav nav-text">Reference</span></a></li></ol>
    </nav>
  </aside>
  <span id="sidebar-ctrl" class="glyphicon glyphicon-list-alt circle"></span>
  <div id="wrapper">
    <header>
  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#nav-menu" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">SixDegree</a>
      </div>
      <div class="collapse navbar-collapse" id="nav-menu">
        <ul class="nav navbar-nav navbar-right">
          
              <li  >
                <a href="/">Blogs</a>
              </li>
          
              <li  >
                <a href="/tags.html">Tags</a>
              </li>
          
              <li  >
                <a href="/about.html">About</a>
              </li>
          
          
              <li>
                <a href="/atom.xml" target="_blank">
                  <span class="icon-rss"></span>
                </a>
              </li>
          
              <li>
                <a href="http://github.com/sixdegree" target="_blank">
                  <span class="icon-github"></span>
                </a>
              </li>
          
        </ul>
      </div>
    </div>
  </nav>
</header>



    <div class="container">
      <article class="detail" role="main">
  <section class="post-header">
    <h1 class="post-title">Python 基础</h1>
    <ul class="post-meta">
      <li>
        <span class="glyphicon glyphicon-calendar"></span>
        <time datetime="2019-03-10T16:00:00.000Z">2019-03-11</time>
      </li>
      
        <li>
         <span class="glyphicon glyphicon-tags"></span>
          
            <a href="/tags.html#tag-Python">Python</a>
          
        </li>
      
    </ul>
  </section>
  <section class="post-content">
    <h2 id="header-1">Starter</h2>
<ul>
<li><a href="https://www.python.org/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://docs.python.org/3/library/" target="_blank" rel="noopener">Python Standard Library</a></li>
<li><a href="https://pypi.org/" target="_blank" rel="noopener">Python Package Index</a>  </li>
<li>安装 <code>python</code> ：<ul>
<li>mac: <code>brew install python3</code></li>
<li>windows: download and install from python website</li>
</ul>
</li>
<li>包管理工具 <code>pip</code>:<ul>
<li><code>pip/pip3 [cmd] [opts]</code></li>
<li>eg: <code>pip instal xxx</code>,<code>pip install --upgrade xxx</code>,<code>pip install xxx==version</code>,<code>pip uninstall xxx</code>,<code>pip list</code></li>
</ul>
</li>
</ul>
<h3 id="header-2">开发环境 (IDE)</h3>
<ol>
<li><p>python自带的开发环境</p>
<pre><code class="lang-bash"> # 交互式
 $ python
 Python 3.7.2 (tags/v3.7.2:9a3ffc0492, Dec 23 2018, 23:09:28) [MSC v.1916 64 bit (AMD64)] on win32
 Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
 &gt;&gt;&gt; 100+200
 300
 &gt;&gt;&gt; exit()
</code></pre>
<pre><code class="lang-bash"> # 直接运行
 $ python hello.py
 100+200=300
</code></pre>
<pre><code class="lang-bash"> # 调试：
 # pdb调试器, 以参数`-m pdb`启动，输入命令`n`单步执行代码，`p 变量名`查看变量，`q`  结束调试退出程序
 D:\Space\python&gt; python -m pdb hello.py
 &gt; d:\space\python\hello.py(2)&lt;module&gt;()
 -&gt; print(&#39;--- Print --- &#39;)
 (Pdb) n
 --- Print ---
 &gt; d:\space\python\hello.py(3)&lt;module&gt;()
 -&gt; print(&#39;100+200=&#39;+str(100+200))
 (Pdb) n
 100+200=300
 &gt; d:\space\python\hello.py(4)&lt;module&gt;()
 -&gt; print(&#39;100+200=&#39;,100+200)
 (Pdb) n
 100+200= 300
 &gt; d:\space\python\hello.py(7)&lt;module&gt;()
 -&gt; print(&#39;--- Inport --- &#39;)
 (Pdb) n
 --- Inport ---
 &gt; d:\space\python\hello.py(8)&lt;module&gt;()
 -&gt; name=input(&#39;input name:&#39;)
 (Pdb) n
 input name:Tom
 &gt; d:\space\python\hello.py(9)&lt;module&gt;()
 -&gt; print(&#39;Hello &#39;+name)
 (Pdb) p name
 &#39;Tom&#39;
 (Pdb) n
 Hello Tom
 &gt; d:\space\python\hello.py(12)&lt;module&gt;()
 -&gt; print(&#39;--- Function --- &#39;)
 (Pdb) q

 D:\Space\python&gt;
</code></pre>
</li>
<li><p>Anaconda </p>
<ul>
<li>开源免费 <a href="https://www.anaconda.com/distribution" target="_blank" rel="noopener">Download</a></li>
<li>一个集成各类Python工具的集成平台</li>
<li>包括 conda包管理工具, 某版本Python, 一批第三方库，编程工具Spyder，交互式编程工具IPython,网页交互式编程工具Jupyter Notebook等</li>
<li><p><code>ipython</code></p>
<ul>
<li><code>?</code>: 变量前或后增加<code>?</code>将显示一些通用信息,包括函数对应的源代码</li>
<li><code>%</code><ul>
<li><code>%run</code>: 用于运行<code>.py</code>程序 (注意在一个空的命名空间执行<code>%</code>)</li>
<li><code>%magic</code>: 显示所有魔术命令</li>
<li><code>%hist</code>: IPython命令的输入历史</li>
<li><code>%pdb</code>: 异常发生后是否自动进入调试器</li>
<li><code>%reset</code>: 重置，即删除当前命名空间中的全部变量或名称</li>
<li><code>%who</code>: 显示Ipython当前命名空间中已经定义的变量</li>
<li><code>%time</code>: 给出代码的执行时间 </li>
<li><code>%timeit</code>: 多次执行代码,计算综合平均执行时间</li>
</ul>
</li>
</ul>
</li>
<li><p><code>conda</code> 包管理和环境管理工具</p>
<ul>
<li>包管理与pip类似,管理Python第三方库 </li>
<li>环境管理能够允许用户使用不同版本Python,并能灵活切换</li>
<li><p>常用命令：</p>
<ul>
<li>获取conda版本 <code>conda ‐‐version</code></li>
<li>升级conda <code>conda update conda</code></li>
<li>下载／卸载包 <code>conda install/uninstall xxx</code></li>
<li>列出安装的包 <code>conda list</code></li>
<li>搜索包 <code>conda search xxx</code> eg: <code>conda search numpy&gt;=1.12</code></li>
<li><p>创建／启用／退出env <code>conda create/activate/deactivate xxx</code></p>
<pre><code class="lang-python">  # conda activate/deactivate envName
  $ conda activate base
  (base) $ ipython3
  Python 3.7.3 (default, Mar 27 2019, 16:54:48)
  Type &#39;copyright&#39;, &#39;credits&#39; or &#39;license&#39; for more information
  IPython 7.4.0 -- An enhanced Interactive Python. Type &#39;?&#39; for help.

  In [1]: 100+200
  Out[1]: 300

  In [2]: exit()
  (base) $
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>PyCharm </p>
<ul>
<li>Community版本免费 <a href="http://www.jetbrains.com/pycharm" target="_blank" rel="noopener">Download</a></li>
<li>类似 Eclipse，有调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制等功能</li>
<li><code>Preference -&gt; Project Interpreter -&gt; 配置 environment</code> (若安装)</li>
</ul>
</li>
</ol>
<h2 id="header-3">基础</h2>
<h3 id="header-4">关键字</h3>
<pre><code class="lang-python">&gt;&gt;&gt; import keyword
&gt;&gt;&gt; help(keyword)
&gt;&gt;&gt; keyword.kwlist
[&#39;False&#39;, &#39;None&#39;, &#39;True&#39;, &#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;async&#39;, &#39;await&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;nonlocal&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;]
</code></pre>
<h3 id="header-5">注释</h3>
<ul>
<li>单行注释<pre><code class="lang-python">  # Test
  print(&quot;Hello World&quot;)
</code></pre>
</li>
<li>多行注释<pre><code class="lang-python">  &#39;&#39;&#39;
  This is test program
  Author: CJ
  Date: 2019/03/10
  &#39;&#39;&#39;
</code></pre>
</li>
<li>中文支持(for <code>Syntax Error:Non-ASCII Character ...</code>)<pre><code class="lang-python">  # -*- coding:utf-8 -*-
  print(&#39;你好&#39;)
</code></pre>
<ul>
<li>注：<code># -*- coding:utf-8 -*-</code> 一般放文件首行</li>
</ul>
</li>
</ul>
<h3 id="header-6">输出</h3>
<pre><code class="lang-python"># 1. &quot;&quot;,&#39;&#39;,&#39;&#39;&#39;
print(&#39;123&#39;)
print(12)

print(&quot;It&#39;s a.&quot;)
print(&#39;It\&#39;s a.&#39;)

print(&quot;Hello &#39;Tom&#39;.&quot;)    # Hello &#39;Tom&#39;.
print(&#39;Hello &quot;Tom&quot;.&#39;)    # Hello &quot;Tom&quot;.

# 2. &#39;&#39;&#39;,\n

print(&#39;sdf\nsdfd&#39;)
print(&#39;&#39;&#39;sdf
sdfd
&#39;&#39;&#39;)

print(&#39;&#39;&#39;Hello Tom.
Miss you
How are you?&#39;&#39;&#39;)
#Hello Tom.
#Miss you
#How are you?

print(&quot;Hello Tom.\nMiss you\nHow are you?&quot;)
#Hello Tom.
#Miss you
#How are you?

# 3. a b
print(&quot;Hello&quot;,&quot;Tom&quot;) # Hello Tom

# 4. %
print(&quot;Hello %s&quot; % &quot;Tom&quot;)    # Hello Tom
print(&quot;a=%d&quot; % 123.5)        # a=123
print(&quot;Hello %s,a=%d&quot; % (&quot;Tom&quot;,123.5)) # Hello Tom,a=123

x=[1,2,3]
print(&quot;Hello %s&quot; % x)        # Hello [1, 2, 3]

x=&quot;Hello %s,a=%d&quot;
print(x % (&quot;Tom&quot;,123.5))    # Hello Tom,a=123

x=&quot;Hello %s,a=%d&quot; % (&quot;Tom&quot;,123.5)
type(x)                        # str
print(x)                    # Hello Tom,a=123

# 5. str,int
x=123
y=&#39;123&#39;
print(x)
print(y)
print(str(x)+y)
</code></pre>
<p><strong>格式化输出，常用的格式符号：</strong></p>
<ul>
<li>字符<ul>
<li><code>%c</code>: 字符</li>
<li><code>%s</code>: 字符串,通过<code>str()</code>字符串转换格式化,eg:<ul>
<li><code>%10s</code>: 右对齐，占位符10位</li>
<li><code>%-10s</code>: 左对齐，占位符10位</li>
<li><code>%.2s</code>: 截取2位字符串</li>
<li><code>%10.2s</code>: 10位占位符，截取两位字符串</li>
</ul>
</li>
</ul>
</li>
<li>整数<ul>
<li><code>%d</code>: dec 十进制整数</li>
<li><code>%o</code>: oct 八进制整数</li>
<li><code>%x</code>: hex 十六进制整数<pre><code class="lang-python">&gt;&gt;&gt; a=123
&gt;&gt;&gt; print(&quot;a=%x&quot; % a)
a=7b
&gt;&gt;&gt; print(&quot;a=%X&quot; % a)
a=7B
</code></pre>
</li>
</ul>
</li>
<li><p>小数</p>
<ul>
<li><code>%f</code>: 浮点实数(默认保留小数点后面六位有效数字)<ul>
<li><code>%.3f</code>: 保留3位小数位</li>
</ul>
</li>
<li><code>%e</code>: 指数形式输出(默认保留小数点后面六位有效数字)<br>　　* <code>%.3e</code>: 保留3位小数位，使用科学计数法</li>
<li><p><code>%g</code>: <code>%f+%e</code>（默认保证六位有效数字）<br>　　* <code>%.3g</code>: 保留3位有效数字，使用小数或科学计数法</p>
<pre><code class="lang-python">&gt;&gt;&gt; a=123.5

# f%
&gt;&gt;&gt; print(&quot;a1=%f,a2=%.3f&quot; % (a,a))
a1=123.500000,a2=123.500

# e%
&gt;&gt;&gt; print(&quot;a=%e,a=%.3e&quot; % (a,a))
a1=1.235000e+02,a2=1.235e+02

# g%
&gt;&gt;&gt; print(&quot;a=%g&quot; % a)
a=123.5
&gt;&gt;&gt; print(&quot;a=%.2g&quot; % a)
a=1.2e+02
&gt;&gt;&gt; print(&quot;a=%.3g&quot; % a)
a=124
&gt;&gt;&gt; print(&quot;a=%.5g&quot; % a)
a=123.5
&gt;&gt;&gt; print(&quot;a=%g&quot; % 123.56789)
a=123.568
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="header-7">输入</h3>
<p><code>input(prompt=None)</code> </p>
<p>注意：input获取的数据，都以字符串的方式进行保存</p>
<pre><code class="lang-python">&gt;&gt;&gt; a=input()
Tom
&gt;&gt;&gt; print(a)
Tom

&gt;&gt;&gt; a=input(&quot;Enter your name:&quot;)
Enter your name:Tom
&gt;&gt;&gt; print(a)
Tom

&gt;&gt;&gt; a=input(&quot;Enter your num:&quot;)
Enter you num: 123
&gt;&gt;&gt; print(a)
123
&gt;&gt;&gt; type(a)
&lt;class &#39;str&#39;&gt;
</code></pre>
<pre><code class="lang-python">name=input(&#39;name:&#39;)        # 输入值会被强制性地转换为字符串类型
print(&#39;Hi &#39;+name);

age=int(input(&#39;age:&#39;))
print(&#39;get age:&#39;+str(age))
</code></pre>
<h3 id="header-8">运算符</h3>
<ol>
<li><p>算术运算符</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">加</td>
<td style="text-align:left">print(10+20) =&gt; 30</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">减</td>
<td style="text-align:left">print(10-20) =&gt; -10</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">乘</td>
<td style="text-align:left">print(a<em>b) =&gt; 200 ; print(‘##’</em>3) =&gt; ######</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">除</td>
<td style="text-align:left">print(10/20) =&gt; 0.5</td>
</tr>
<tr>
<td style="text-align:left"><code>//</code></td>
<td style="text-align:left">取整除</td>
<td style="text-align:left">print(10//20) =&gt; 0 ; print(20/10) =&gt; 2</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">取余</td>
<td style="text-align:left">print(20%10) =&gt; 0 ; print(20/3) =&gt; 2</td>
</tr>
<tr>
<td style="text-align:left"><code>**</code></td>
<td style="text-align:left">幂</td>
<td style="text-align:left">print(2**3) =&gt; 8</td>
</tr>
</tbody>
</table>
</li>
<li><p>比较运算符: <code>==</code>,<code>!=</code>,<code>&lt;&gt;</code>,<code>&gt;</code>,<code>&lt;</code>,<code>&gt;=</code>,<code>&lt;=</code></p>
</li>
<li><p>逻辑运算符：<code>and</code>,<code>or</code>,<code>not</code></p>
</li>
</ol>
<h3 id="header-9">判断语句</h3>
<p>keyword: <code>if</code>,<code>elif</code>,<code>else</code></p>
<pre><code class="lang-python"># if-else
a=100
if a&gt;100:
    print(&#39;a&gt;100&#39;)
else
    print(&#39;a&lt;=100&#39;)

# if-elif(else)
if a&gt;100:
    print(&#39;a&gt;50&#39;)
elif a==100:
    print(&#39;a==100&#39;)
elif a&lt;100 and a&gt;50:
    print(&#39;a (50,100)&#39;)
else:
    print(&#39;a&lt;=50&#39;)
</code></pre>
<h3 id="header-10">循环语句</h3>
<p>keyword: <code>for</code>,<code>while</code>,<code>break</code>,<code>continue</code></p>
<pre><code class="lang-python"># while
i=0
while i&lt;100:
    if i%2==0
        print(i,&quot;偶数&quot;)
    else
        print(i,&quot;奇数&quot;)
    i+=1
</code></pre>
<pre><code class="lang-python"># for in
# sample1:
for i in &#39;abcdefg123456&#39;:
    if i==&#39;d&#39;:
        print(&#39;find d before 5&#39;)
        continue
    if i==&#39;5&#39;:
        break
    print(i)

# sample2:
for i in range(10):
    if i == 11:
        print(&#39;找到结果&#39;)
        break
else:
    print(&#39;未找到结果&#39;)
</code></pre>
<h3 id="header-11">异常处理</h3>
<ul>
<li>Python的错误也是class，所有的错误类型都继承自<code>BaseException</code>，可使用继承自定义异常类</li>
<li>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出</li>
<li>捕获异常：<ul>
<li><code>try...except...</code></li>
<li><code>try...finally...</code></li>
<li><code>try...except...else...</code></li>
<li><code>try...except...finally...</code></li>
<li><code>try...except...else...finally...</code></li>
<li>说明：<ul>
<li>捕获到<code>except</code>中匹配的异常，则执行<code>except</code>下的语句，反之则执行<code>else</code>中的语句</li>
<li>无论是否捕获到异常，都会执行<code>finally</code>中的语句</li>
</ul>
</li>
</ul>
</li>
<li>手动抛出异常：<code>raise 异常实例</code> （注：在<code>except</code>中可直接用<code>raise</code>重新抛出捕获的异常）</li>
<li>借助Python内置的<code>logging</code>模块，可以容易地记录错误信息（输出或记录到文件），方便事后排查</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 1. 捕获某个异常
def testCatchOneException():                
    try:
        print(&#39;Begin&#39;)
        open(&#39;test.json&#39;,&#39;r&#39;)        # 若test.json不存在，则会产生 IOError 异常
        print(&#39;End&#39;)
    except IOError:                 # 用变量记录可使用 `except IOError as ex:`
        print(&#39;Catch IOError&#39;)
    else:
        print(&#39;Not catch&#39;)
    finally:
        print(&#39;Done&#39;)

# 2. 捕获多个异常
def testCatchMultiException():                 
    try:
        print(&#39;Begin&#39;)
        open(&#39;test.json&#39;,&#39;r&#39;)         # 若test.json不存在，则会产生 IOError 异常
        print(&#39;then&#39;)
        print(num)                     # 若num未定义，则会会产生 NameError 异常
        print(&#39;End&#39;)
    except IOError or NameError:     # catch IOError or NameError
        print(&#39;Catch Error&#39;)
    except:                            # catch other all exception (under BaseException)
        print(&#39;Catch Error&#39;)    
    else:
        print(&#39;Not catch&#39;)
    finally:
        print(&#39;Done&#39;)

# 3. 用变量保存捕获到的异常
def testRecordException():
    try:
        print(&#39;Begin&#39;)
        open(&#39;test.json&#39;,&#39;r&#39;)
        print(&#39;Then&#39;)
        print(num)
        print(&#39;End&#39;)
    except (IOError,NameError) as ex:     # 等同：`except IOError or NameError as ex:`
        print(&#39;Catch error:&#39;,type(ex),ex)

# 4. 用raise抛出异常
def testRaiseException1():
    try:
        print(&#39;Begin&#39;)
        raise ValueError(&#39;Hello&#39;,1,2)    # 抛出异常(异常实例，构造可传入任意参数，无限制)
        print(&#39;End&#39;)
    except:                             # 捕获异常
        print(&#39;Catch Error&#39;)             # 记录一下
        raise                             # 再抛出
    finally:
        print(&#39;Done&#39;)

def testRaiseException2():
    try:
        print(&#39;Begin&#39;)
        open(&#39;test.json&#39;,&#39;r&#39;)
        print(&#39;then&#39;)
        print(num)
        print(&#39;End&#39;)
    except (IOError,NameError) as ex:
        print(&#39;Catch error:&#39;,type(ex),ex)
        raise         # 抛出发生的IOError或NameError异常实例，
                    # 也可抛出另一个异常实例，如：`raise ValueError(msg)`
    finally:
        print(&#39;Done&#39;)

# 5. 使用logging模块，记录错误信息
import logging
def testLogException():
    try:
        print(&#39;Begin&#39;)
        raise ValueError(&#39;Hello&#39;)
        print(&#39;End&#39;)
    except Exception as ex:
        print(&quot;Catch error:&quot;,type(ex),ex)
        logging.exception(ex)
    finally:
        print(&quot;Done&quot;)

&gt;&gt;&gt; testLogException()
Begin
Catch error: &lt;class &#39;ValueError&#39;&gt; Hello
ERROR:root:Hello
Traceback (most recent call last):
  File &quot;&lt;ipython-input-34-817d16b0d2f0&gt;&quot;, line 4, in testLogException
    raise ValueError(&#39;Hello&#39;)
ValueError: Hello
Done
</code></pre>
<p><strong>Python Build-in Exceptions</strong></p>
<p>Refer <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy" target="_blank" rel="noopener">Doc</a></p>
<pre><code>BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
</code></pre><h3 id="header-12">给程序传参</h3>
<pre><code class="lang-python">$ vi argv-demo.py
import sys
print(&quot;Hello argv:&quot;,sys.argv)

$ python3 argv-demo.py abc 123 456
Hello argv: [&#39;argv-demo.py&#39;, &#39;abc&#39;, &#39;123&#39;, &#39;456&#39;]
</code></pre>
<h3 id="header-13">测试</h3>
<ol>
<li><p>单元测试 <code>unittest</code></p>
<ul>
<li>导入包：<code>import unittest</code></li>
<li>编写测试类（继承自<code>unittest.TestCase</code>）：<code>class Xxx(unittest.TestCase)</code> </li>
<li>编写测试函数（以test开头）: <code>def testXxx()</code></li>
<li>添加测试切面函数（自动在每一个测试方法前后执行）：<code>setUp()</code>,<code>tearDown()</code></li>
<li>运行：<ul>
<li>method1: 添加：<code>if __name__ == &#39;__main__&#39;:unittest.main()</code>，执行：<code>python unittest-demo.py</code></li>
<li>method2: 直接执行<code>python -m unittest unittest-demo.py</code></li>
</ul>
</li>
</ul>
</li>
<li><p>文档测试 <code>doctest</code></p>
<ul>
<li>导入包：<code>import doctest</code></li>
<li>doctest 模块可以直接提取py开始的注释和函数开始的注释<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code></li>
<li>运行：<code>if __name__==&#39;__main__&#39;: doctest.testmod()</code></li>
</ul>
</li>
</ol>
<p><strong>Sample1: 单元测试 unittest</strong></p>
<pre><code class="lang-python">import unittest

class MyTest(unittest.TestCase):
    def setUp(self):
        print(&#39;setUp...&#39;)

    def tearDown(self):
        print(&#39;tearDown...&#39;)

    def test_dict(self):
        print(&#39;test 1&#39;)
        d={&#39;a&#39;:1,&#39;b&#39;:2}
        self.assertEqual(d[&#39;a&#39;],1)
        self.assertEqual(d[&#39;b&#39;],2)
        self.assertTrue(isinstance(d, dict))

    def testdict2(self):
        print(&#39;test 2&#39;)
        d={&#39;a&#39;:1,&#39;b&#39;:2}
        with self.assertRaises(KeyError):   # 期待抛出指定类型的Error
            value = d[&#39;c&#39;]

if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>
<pre><code class="lang-bash">$ python unittest-demo.py
setUp...
test 1
tearDown...
.setUp...
test 2
tearDown...
.
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
</code></pre>
<p><strong>Sample2:文档测试 doctest</strong></p>
<pre><code class="lang-python">&#39;&#39;&#39;
&gt;&gt;&gt; hello([4,5,6])
hello: [4,5,6]
&#39;&#39;&#39;
def hello(x):
    &#39;&#39;&#39;
    doc test demo -- helo

    &gt;&gt;&gt; hello(&#39;Tom&#39;)
    hello: Tom
    &gt;&gt;&gt; hello(1/0)
    Traceback (most recent call last):
    ...
    ZeroDivisionError: division by zero
    &gt;&gt;&gt; hello([1,2,3])
    hello: [1,2,3]
    &#39;&#39;&#39;
    print(&#39;hello:&#39;,x)


if __name__==&#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>
<pre><code class="lang-python">$ python doctest-demo.py
**********************************************************************
File &quot;doctest-demo.py&quot;, line 2, in __main__
Failed example:
    hello([4,5,6])
Expected:
    hello: [4,5,6]
Got:
    hello: [4, 5, 6]
**********************************************************************
File &quot;doctest-demo.py&quot;, line 15, in __main__.hello
Failed example:
    hello([1,2,3])
Expected:
    hello: [1,2,3]
Got:
    hello: [1, 2, 3]
**********************************************************************
2 items had failures:
   1 of   1 in __main__
   1 of   3 in __main__.hello
***Test Failed*** 2 failures.
</code></pre>
<h2 id="header-14">基础数据类型</h2>
<h3 id="header-15">不可变对象 &amp; 可变对象</h3>
<ol>
<li><p>不可变对象：即无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象 (=&gt; 可做key)</p>
<ul>
<li>整数 <code>int</code> eg: <code>a=123</code></li>
<li>浮点数 <code>float</code> eg: <code>a=123.0</code></li>
<li>布尔 <code>bool</code> eg: <code>a=True</code>,<code>a=False</code>,<code>a=bool(1)</code>,<code>bool(&#39;&#39;)</code></li>
<li>字符串 <code>str</code> eg: <code>a=&quot;123abc&quot;</code></li>
<li>元祖 <code>tuple</code> eg: <code>a=(1,23.4,&#39;ef&#39;)</code></li>
<li>空 <code>NoneType</code> eg: <code>a=None</code></li>
</ul>
</li>
<li><p>可变对象(=&gt; 不可做key)</p>
<ul>
<li>列表 <code>list</code> eg: <code>a=[1,23.4,&#39;ef&#39;]</code></li>
<li>字典 <code>dict</code> eg: <code>a={&#39;a&#39;:1,1:&#39;d&#39;,(1,2):&#39;123&#39;}</code></li>
<li>集合 <code>set</code> eg: <code>a={1,2,&#39;ef&#39;,12.4}</code>    </li>
</ul>
</li>
<li><p>对象比较</p>
<ul>
<li><code>id(obj)</code> 查看对象的唯一标识 </li>
<li><code>==</code> 比较两个对象内容是否相等</li>
<li><code>is</code> 比较两个对象是否相等（是否是同一块地址空间）</li>
</ul>
</li>
</ol>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 1. 不可变对象：int
&gt;&gt;&gt; a=555
&gt;&gt;&gt; b=a

&gt;&gt;&gt; id(a),id(b)                # a和b相等，指向同一个地址空间
(4566055600,4566055600)

&gt;&gt;&gt; b=789                     # b指向新开辟的另一个地址空间,a与b不同了
&gt;&gt;&gt; id(a),id(b)
(4324742368,4566055696)

# 2. 可变对象：list
&gt;&gt;&gt; a=[1,2,3]
&gt;&gt;&gt; b=a

&gt;&gt;&gt; id(a),id(b)             # a和b相等，指向同一个地址空间
(4333307784,4333307784)

&gt;&gt;&gt; b.append(4)             # b和a依旧相等，指向同一块地址空间
&gt;&gt;&gt; id(a),id(b)
(4333307784,4333307784)

&gt;&gt;&gt; import copy
&gt;&gt;&gt; c=copy.deepcopy(a)         # 拷贝内容（开辟了一块新空间存储被拷贝对象的所有内容）,相当于执行了c=[1,2,3]
&gt;&gt;&gt; id(a),id(c)
(4333307784,4397232200)
&gt;&gt;&gt; a==c,a is c             # a与c内容相同，但指向不同地址空间
(True,False)
</code></pre>
<h3 id="header-16">垃圾回收机制</h3>
<ol>
<li><p>intern机制：Python为了优化速度，对一些对象使用了对象池，避免为频繁申请和销毁内存空间</p>
<pre><code class="lang-python"> # 小整数：共用对象
 &gt;&gt;&gt; a=123
 &gt;&gt;&gt; b=123
 &gt;&gt;&gt; id(a),id(b),id(123)             # 相同
 (4557612256, 4557612256, 4557612256)

 # 大整数：不共用对象
 &gt;&gt;&gt; a=789
 &gt;&gt;&gt; b=789
 &gt;&gt;&gt; id(a),id(b),id(789)             # 不相同
 (4566055600, 4566055760, 4561935984)

 # 一个字符：共用对象
 &gt;&gt;&gt; a=&#39;A&#39;
 &gt;&gt;&gt; b=&#39;A&#39;
 &gt;&gt;&gt; id(a),id(b),id(&#39;A&#39;)              # 相同
 (4562778576, 4562778576,4562778576)

 # 一个单词：共用对象
 &gt;&gt;&gt; a=&quot;Hello&quot;
 &gt;&gt;&gt; b=&quot;Hello&quot;
 &gt;&gt;&gt; id(a),id(b),id(&quot;Hello&quot;)         # 相同
 (4566204968, 4566204968,4566204968)

 # 非单词字符串：不共用对象
 &gt;&gt;&gt; a=&quot;Hello World&quot;
 &gt;&gt;&gt; b=&quot;Hello World&quot;
 &gt;&gt;&gt; id(a),id(b),id(&quot;Hello World&quot;)   # 不相同
 (4564866736, 4565787824, 4565787888)
</code></pre>
<ul>
<li><code>小整数[-5,257)</code>: 共用对象，常驻内存</li>
<li><code>单个字符</code>: 共用对象，常驻内存</li>
<li><code>单个单词</code>: 共用对象，不常驻内存，引用计数为0时销毁</li>
<li>注：<ul>
<li>非单个但单词的字符串（如含有空格等），不会使用intern机制（即不共用对象），引用计数为0则销毁</li>
<li>数值类型和字符串类型在Python中都是不可变类型，即无法修改这个对象的值，每次对变量的修改，实际上是创建一个新的对象</li>
</ul>
</li>
</ul>
</li>
<li><p>引用计数</p>
<pre><code class="lang-python"> # 查看一个对象的引用计数
 &gt;&gt;&gt; import sys
 &gt;&gt;&gt; a=&quot;Hello World&quot;
 &gt;&gt;&gt; sys.getrefcount(a)  # 比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1
 2
 &gt;&gt;&gt; b=a
 &gt;&gt;&gt; sys.getrefcount(a)
 3 
 &gt;&gt;&gt; del b
 &gt;&gt;&gt; sys.getrefcount(a)
 2
</code></pre>
<ul>
<li>一旦引用计数为0则销毁以释放内存，具有实时性，处理回收内存的时间分摊到了平时（不用像其他机制等到特定时机）</li>
<li>循环引用所占用的内存永远无法被回收</li>
<li>维护消耗资源：占空间且处理相对较慢</li>
</ul>
</li>
<li><p>标记-清除（判别出垃圾清除）</p>
<ul>
<li>标记出有指针引用的对象，剩下未被标记的对象则为垃圾，可进行清除</li>
</ul>
</li>
<li><p>分代收集 Generational GC（可处理循环引用释放问题）</p>
<ul>
<li>使用链表来持续追踪活跃对象</li>
<li>内部使用多代（个）链表：Generation Zero &amp; Generation One &amp; Generation Two（新创建的对象放入Generation Zero链表）</li>
<li>周期性地检查链表，根据规则减掉上面互相引用的对象的引用计数，清除引用计数为0的对象，剩下的活跃对象则移动到下一代链表</li>
<li>GC阈值：一旦被分配对象与被释放对象的计数值之差达到阈值，就启动检查，释放“浮动的垃圾”，活跃对象移动到下一代链表</li>
</ul>
</li>
<li><p><code>gc</code>模块: 提供设置垃圾回收的API</p>
<ul>
<li><code>gc.isenabled()</code></li>
<li><code>gc.disable()</code></li>
<li><code>gc.set_debug(flags)</code> 设置gc的debug日志，一般设置为<code>gc.DEBUG_LEAK</code></li>
<li><code>gc.collect(generation=2)</code>: <ul>
<li>0: 只检查0代的对象；</li>
<li>1:检查0，1代对象；</li>
<li>2:检查0，1，2代对象；</li>
<li>返回收集的垃圾数</li>
</ul>
</li>
<li><code>gc.get_count()</code>:<ul>
<li>返回一个长度为3的元组，代表各代自动执行垃圾回收的计数器</li>
<li>eg: (488,0,0) 488是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目</li>
</ul>
</li>
<li><code>gc.get_threshold()</code>:<ul>
<li>返回一个长度为3的元组，代表各代自动执行垃圾回收的阈值</li>
<li>每一次计数器增加，gc模块会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器</li>
<li>eg:(700,10,10)</li>
</ul>
</li>
<li><code>gc.set_threshold(threshold0[, threshold1[, threshold2])</code> <ul>
<li>设置各代阈值</li>
</ul>
</li>
<li>eg: 阈值:(700,10,10), 计数器:<ul>
<li>(699,3,0)增到(700,3,0)时 =&gt; gc模块执行<code>gc.collect(0)</code>检查0代对象的垃圾，重置计数器为<code>(0,4,0)</code></li>
<li>(699,9,0)增到(700,9,0)时 =&gt; gc模块执行<code>gc.collect(1)</code>检查1,2代对象的垃圾，重置计数器为<code>(0,0,1)</code></li>
<li>(699,9,9)增到(700,9,9)时 =&gt; gc模块执行<code>gc.collect(2)</code>检查0,1,2,3代对象的垃圾，重置计数器为<code>(0,0,0)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>垃圾回收触发点：</p>
<ul>
<li>调用<code>gc.collect()</code></li>
<li><code>gc</code>模块的计数器达到阀值时</li>
<li>程序退出时</li>
</ul>
</li>
<li><p>总结：</p>
<ul>
<li>Python中使用<code>intern机制</code>共用一些对象以优化速度</li>
<li>垃圾回收采用<code>引用计数</code>为主，<code>标记-清除</code>+<code>分代收集</code>为辅的策略</li>
<li><code>gc</code>模块提供垃圾回收的API</li>
</ul>
</li>
</ol>
<h3 id="header-17">类型转换</h3>
<ol>
<li><p>整数：<code>int(x [,base ])</code> </p>
<ul>
<li><code>int(20.4)</code> =&gt; 20</li>
<li><code>int(&#39;20.4&#39;)</code> =&gt; Error</li>
<li><code>int(&#39;89&#39;)</code> =&gt; 89</li>
<li><code>int(&quot;0xc&quot;,base=16)</code> =&gt; 12</li>
</ul>
</li>
<li><p>浮点数： <code>float(x)</code></p>
<ul>
<li><code>float(&quot;123&quot;)</code>,<code>flaot(123)</code> =&gt; 123.0</li>
<li><code>float(&quot;123.5&quot;)</code>,<code>float(123.5)</code> =&gt; 123.5</li>
<li><code>float(&quot;12e+2&quot;)</code>,<code>float(12e+2)</code> =&gt; 1200.0</li>
</ul>
</li>
<li><p>字符串: <code>str(obj)</code> 参数可为任意对象</p>
<ul>
<li><code>str(123.5)</code>,<code>str(&quot;123.5&quot;)</code> =&gt; “123.5”</li>
<li><code>str([12,123.5,&quot;se&quot;])</code> =&gt; “[12, 123.5, ‘se’]”</li>
<li><code>str({&#39;a&#39;:1,&#39;b&#39;:2})</code> =&gt; “{‘a’: 1, ‘b’: 2}”</li>
</ul>
</li>
<li><p>元组：    <code>tuple(s)</code> 参数可以是元组,列表,字典(只取keys),集合,字符串</p>
<ul>
<li><code>tuple((1,2,3))</code> =&gt; (1,2,3)</li>
<li><code>tuple([1,2,3])</code> =&gt; (1,2,3)</li>
<li><code>tuple({&#39;a&#39;:1,&#39;b&#39;:2})</code> =&gt; (‘a’, ‘b’)</li>
<li><code>tuple({1, 23.0, &#39;ef&#39;})</code> =&gt; (1, 23.0, ‘ef’)</li>
<li><code>tuple(&#39;123&#39;)</code> =&gt; (‘1’, ‘2’, ‘3’)</li>
</ul>
</li>
<li><p>列表：<code>list(s)</code> 参数可为元组,字典,列表,字典(只取keys),集合,字符串</p>
<ul>
<li><code>list([1,2,3])</code> =&gt; [1,2,3]</li>
<li><code>list((1,2,3))</code> =&gt; [1,2,3]</li>
<li><code>list({&#39;a&#39;:1,&#39;b&#39;:2})</code> =&gt; [‘a’, ‘b’]</li>
<li><code>list(&#39;123&#39;)</code> =&gt; [‘1’,’2’,’3’]</li>
<li><code>list(set([1,2,3]))</code> =&gt; [1,2,3]</li>
</ul>
</li>
<li><p>集合：<code>set(s)</code> 参数可以是元组,列表,字典(只取keys),集合,字符串</p>
<ul>
<li><code>set((1,2,3))</code> =&gt; {1,2,3}</li>
<li><code>set({1,2,3})</code> =&gt; {1,2,3}</li>
<li><code>set([1,2,2,3,1,2])</code> =&gt; {1,2,3}</li>
<li><code>set({&#39;a&#39;:1,&#39;b&#39;:2})</code> =&gt; {‘a’, ‘b’}</li>
<li><code>set(&#39;123&#39;)</code> =&gt; {‘2’, ‘3’, ‘1’}</li>
</ul>
</li>
<li><p>其他：</p>
<ul>
<li>整数转换某进制(字符串表示)<ul>
<li><code>hex(x)</code> : 把一个整数转换为十六进制字符串 eg: <code>hex(12)</code> =&gt; ‘0xc’</li>
<li><code>oct(x)</code> : 把一个整数转换为八进制字符串 eg: <code>oct(12)</code> =&gt; ‘0o14’</li>
</ul>
</li>
<li>执行一个字符串表达式，返回计算的结果: <code>eval(str)</code><ul>
<li><code>eval(&quot;12+23&quot;)</code> =&gt; 35</li>
</ul>
</li>
<li>利用<code>enumerate</code>将list中的item转换为tuple<pre><code class="lang-python">  &gt;&gt;&gt; seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]
  &gt;&gt;&gt; list(enumerate(seasons))
  [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-18">字符编码</h3>
<ol>
<li><p><code>ASCII</code> &amp; <code>Unicode</code> &amp; <code>UTF-8</code>编码</p>
<ul>
<li><code>ASCII</code> : 1个字节</li>
<li><code>Unicode</code> : 2个字节(偏僻的字符要4个字节)</li>
<li><code>UTF-8</code> : 可变长编码,能节省空间(把一个Unicode字符根据不同的数字大小编码成1-6个字节,英文字母1个字节,汉字通常是3个字节,偏僻的字符要4~6个字节)</li>
<li><p>eg:</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">ASCII</th>
<th style="text-align:left">Unicode</th>
<th style="text-align:left">UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">01000001</td>
<td style="text-align:left">00000000 01000001</td>
<td style="text-align:left">01000001</td>
</tr>
<tr>
<td style="text-align:left">中</td>
<td style="text-align:left">/</td>
<td style="text-align:left">01001110 00101101</td>
<td style="text-align:left">11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li><p>工作方式: </p>
<ul>
<li>在计算机内存中，统一使用<code>Unicode</code>编码，当需要保存到硬盘或者需要传输的时候，就转换为<code>UTF-8</code>编码</li>
<li>python中<code>str</code>在内存中以<code>Unicode</code>表示，一个字符对应若干个字节，传输或者保存到磁盘，则变为以字节为单位的<code>bytes</code></li>
</ul>
</li>
<li><p>获取字符编码的整数表示<code>ord(x)</code></p>
<ul>
<li><code>ord(&#39;a&#39;)</code> =&gt; 97</li>
<li><code>ord(&#39;A&#39;)</code> =&gt; 65</li>
<li><code>ord(&#39;你&#39;)</code> =&gt; 20320</li>
<li><code>ord(&#39;中&#39;)</code> =&gt; 20013</li>
</ul>
</li>
<li><p>把编码转换为对应的字符<code>chr(x)</code></p>
<ul>
<li><code>chr(65)</code> =&gt; ‘A’</li>
<li><code>chr(20013)</code> =&gt; ‘中’</li>
</ul>
</li>
<li><p>encode/decode</p>
<ul>
<li>encode: str -&gt; bytes</li>
<li>decode: str &lt;- bytes</li>
</ul>
</li>
</ol>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 1. encode/decode
a=&#39;abc&#39;
b=a.encode()        
print(b)            # b&#39;abc&#39;
print(b.decode())    # abc

a=&#39;你好&#39;
b=a.encode()
print(b)            # b&#39;\xe4\xbd\xa0\xe5\xa5\xbd&#39;
print(b.decode())    # 你好

# 2. len
#     - len(str)         返回字符数
#     - len(bytes)     返回字节数
a=&#39;abc&#39;
print(len(a))    # 3

a=b&#39;abc&#39;
print(len(a))    # 3

a=&#39;你好&#39;
print(len(a))                    # 2
print(a.encode(&#39;utf-8&#39;))         # b&#39;\xe4\xbd\xa0\xe5\xa5\xbd&#39;
print(len(a.encode(&#39;utf-8&#39;)))    # 6
</code></pre>
<h3 id="header-19">整数：进制转换／位运算</h3>
<ol>
<li><p>进制</p>
<ul>
<li>十进制(逢十进一): 0,1,2,3,4,5,6,7,8,9,10,11,12,…</li>
<li>二进制(逢二进一): 0,1,10,11,100,…</li>
<li>八进制(逢八进一): 0,1,2,3,4,5,6,7,10,11,12,…</li>
<li>十六进制(逢十六进一): 0,1,2,…8,9,10,a,b,c,d,e,f,10,11,12,…</li>
</ul>
</li>
<li><p>计算机存储:</p>
<ul>
<li>以二进制的补码形式存储，人们看到的数字是原码转化来的，而原码是通过补码得到的</li>
<li>即：<code>补码(机器存储) -&gt; 原码 -&gt; 转换对应进制 -&gt; 最后人们看到的数</code></li>
<li>符号位：第一位为符号位，表正数或负数</li>
<li>原码：用来转换对应进制</li>
<li>反码：符号位不变，其他位数取反</li>
<li>补码: 用来做数据的存储运算(运算包括符号位). 补码提出的根源是让计算机底层用加法实现减法操作，即减去一个数＝加上一个负数</li>
<li>进制转换时,需要先把内存中存储的补码拿出来变成原码,再进行转换输出</li>
<li><p>原码,补码转换规则：</p>
<pre><code class="lang-bash">  正数: 5
  补码存储        -&gt; 原码（＝补码）       -&gt; 人们看到的数（一般为十进制)
  0,000,0101      0,000,0101          5

  负数：-5
  补码存储        -&gt; 原码（＝补码取反+1） -&gt; 人们看到的数（一般为十进制)
  1,111,1011       1,000,0101         -5
</code></pre>
<ul>
<li>正数：原码 &lt;=&gt; 补码 （原码＝反码＝补码，即：无需转换）</li>
<li>负数：原码 &lt;=&gt; 取反+1 &lt;=&gt; 补码</li>
</ul>
</li>
<li><p>运算：用补码运算</p>
<pre><code class="lang-bash">  负数：-5
  补码存储        -&gt; 原码（＝补码取反+1） -&gt; 人们看到的数（一般为十进制)
  1,111,1011       1,000,0101         -5

  运算：
  -5 &lt;&lt; 1:
  1,111,0110       1,000,1010         -10

  -5 &gt;&gt; 1
  1,111,1011       1,000,00101        -3

  -5 + 1
  1,111,1100       1,000,0100         -4
</code></pre>
<ul>
<li><code>+,-</code>: 用加法加上正负数, eg: <code>1-1 = 1+(-1) = (1的补码) + (-1的补码) = 0</code></li>
<li><code>*,/</code>: 按位左右移<code>&lt;&lt;,&gt;&gt;</code>, eg: <code>5*2 = 0101&lt;&lt;1 = 1010 = 10</code> , <code>5*3=5*2+5=(0101&lt;&lt;1)+(0101)=1111=15</code></li>
</ul>
</li>
<li>注意：<ul>
<li>运算时用补码，包括符号位</li>
<li>原补码转换（取反）时，不包括符号位</li>
<li>进制间转换时用原码，不包括符号位</li>
</ul>
</li>
</ul>
</li>
<li><p>进制转换</p>
<pre><code class="lang-python"> # 1. 十进制 (type:int) =&gt; `bin(num)`/`oct(num)`/`hex(num)` =&gt; 二进制(0b),八进制(0o),十六进制(0x) (type:str)
 &gt;&gt;&gt; bin(18)
 &#39;0b10010&#39;
 &gt;&gt;&gt; oct(18)
 &#39;0o22&#39;
 &gt;&gt;&gt; hex(18)
 &#39;0x12&#39;

 # 2. 二进制(0b),八进制(0o),十六进制(0x) (type: str) =&gt; `int(strNum,base=10)` =&gt; 十进制 (type: int)
 &gt;&gt;&gt; int(&#39;0b10010&#39;,2)
 &gt;&gt;&gt; int(&#39;0o22&#39;,8)
 &gt;&gt;&gt; int(&#39;0x12&#39;,16)

 # 3. 注：bin(x) 返回的是简写版`符号＋原码`
 &gt;&gt;&gt; bin(5)
 &#39;0b101&#39;
 &gt;&gt;&gt; bin(-5)
 &#39;-0b101&#39;
</code></pre>
</li>
<li><p>位运算: <code>&amp;,|,^,~,&lt;&lt;,&gt;&gt;</code> 直接操作二进制,按位运算，省内存,效率高</p>
<pre><code class="lang-python"> # 1. &lt;&lt; : 左移 = x*(2^n)
 &gt;&gt;&gt; 0b0101&lt;&lt;1
 10
 &gt;&gt;&gt; 5&lt;&lt;1        # = 5*2^1
 10

 &gt;&gt;&gt; 0b0101&lt;&lt;2
 20
 &gt;&gt;&gt; 5&lt;&lt;2        # = 5*2^2
 20

 # 2. &gt;&gt; : 右移 = x//(2^n)
 &gt;&gt;&gt; 5&gt;&gt;1        # = 5//(2^1)
 2
 &gt;&gt;&gt; 5&gt;&gt;2        # = 5//(2^2)
 1
 &gt;&gt;&gt; -5&gt;&gt;1       # = -5//2
 -3

 # 3. &amp;：按位与（都为1则为1）
 &gt;&gt;&gt; 0b0101 &amp; 0b1111
 5
 &gt;&gt;&gt; 5&amp;15
 5

 # 4. |：按位或（有1则为1）
 &gt;&gt;&gt; 0b0101 | 0b1111
 15
 &gt;&gt;&gt; 5|15
 15

 # 5. ^：按位异或（不同则为1）
 &gt;&gt;&gt; 0b0101 ^ 0b1111     # =&gt; 0b1010
 10
 &gt;&gt;&gt; 5^15
 10

 # 6. ~：按位翻转，结果为：`-(x+1)` （注：包括符号位翻转，所以不是反码）
 # eg：
 # 5 补码（正数，与原码相同）：       0000,0101
 # 运算~5（按位全部取反）：          1111,1010
 # 转换为原码（除符号位，取反+1）：    1000,0110   =&gt; -6
 &gt;&gt;&gt; ~0b0101
 -6
 &gt;&gt;&gt; ~5
 -6

 # 5取反+1=-5; -5取反+1=5
 &gt;&gt;&gt; ~5+1
 -5
 &gt;&gt;&gt; ~5
 -6
 &gt;&gt;&gt; ~-5+1
 5
 &gt;&gt;&gt; bin(5)
 &#39;0b101&#39;
 &gt;&gt;&gt; bin(~5)
 &#39;-0b110&#39;
 &gt;&gt;&gt; bin(-5)
 &#39;-0b101&#39;
</code></pre>
</li>
</ol>
<h3 id="header-20">str,tuple,list,set,dict</h3>
<p>常用方法总结：</p>
<ul>
<li>增<ul>
<li>str/tuple: <code>+</code>,<code>*n</code> – 不可改，生成新的</li>
<li>list: <code>+[...]</code>,<code>*n</code>,<code>.append(x)</code>,<code>.extend(iterable)</code>,<code>.insert(index,x)</code></li>
<li>set: <code>.add(key)</code>,<code>.update(iterable)</code></li>
<li>dict: <code>xxx[key]=value</code>,<code>.update({key:value,...})</code>,<code>.setdefault(key,default=None)</code></li>
</ul>
</li>
<li>删<ul>
<li>str/tuple: 不可改</li>
<li>list: <code>del xxx[index]</code>,<code>remove(item)</code>,<code>pop(index=-1)</code></li>
<li>set: <code>.remove(key)</code>,<code>.discard(key)</code>,<code>pop()</code></li>
<li>dict: <code>del xxx[key]</code>,<code>.pop(key)</code>,<code>.popitem()</code></li>
</ul>
</li>
<li>改<ul>
<li>str/tuple: ／</li>
<li>list: <code>xxx[index]=value</code></li>
<li>set: ／</li>
<li>dict: <code>xxx[key]=value</code>,<code>.update({key:value,...})</code>,<code>.setdefault(key,default=None)</code></li>
</ul>
</li>
<li>查<ul>
<li>str/tuple: <code>[index]</code>,<code>[start:end:step]</code>,<code>.index(x,start,end)</code>,<code>.count(x)</code></li>
<li>list: <code>[index]</code>,<code>[start:end:step]</code>,<code>.index(x,start,end)</code>,<code>.count(x)</code></li>
<li>set: /</li>
<li>dict: <code>xxx[key]</code>,<code>.get(key,default=None)</code>,<code>keys()</code>,<code>values()</code>,<code>items()</code></li>
</ul>
</li>
<li>公共方法<ul>
<li><code>in/not in</code> 存在与否 </li>
<li><code>.len(x)</code>,<code>.max(x)</code>,<code>.min(item)</code></li>
<li><code>for item in s</code>,<code>for index,item in enumerate(s)</code> 遍历 (对于dict，会遍历keys)</li>
</ul>
</li>
</ul>
<h3 id="header-21">str</h3>
<p><code>&quot;....&quot;</code>:</p>
<ul>
<li><code>find/rfind/index/rindex/count(str, start=0, end=len(mystr))</code> 注：index方法若是找不到会抛出一个异常</li>
<li><code>replace(str1,str2,count=-1)</code></li>
<li><code>split(sep=None, maxsplit=-1)</code>,<code>splitlines()</code>,<code>join(iterable)</code></li>
<li><code>capitalize/title()</code> 字符串的第一个/每个单词首字母大写</li>
<li><code>lower/upper()</code> 转换为小写／大写</li>
<li><code>startswith/endswith(prefix[, start[, end]])</code> 返回 True/False</li>
<li><code>ljust/rjust/center(width, fillchar=&#39; &#39;)</code> 原字符串左/右／居中对齐,并使用空格填充至长度 width 的新字符串</li>
<li><code>lstrip/rstrip/strip(chars=None)</code> 去除字符串左／右／两边的空白字符</li>
<li><code>rpartition/partition(seq)</code> 从右／左边开始以seq分割成三部分,seq前，seq和seq后</li>
<li><code>isalpha/isdigit/isalnum/isspace</code> 返回True/False</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python">&gt;&gt;&gt; a=&quot;Hello Tom! How are you? Are you ok?&quot;

# find/index/count
&gt;&gt;&gt; a.find(&#39;you&#39;)
19
&gt;&gt;&gt; a.index(&#39;you&#39;)
19
&gt;&gt;&gt; a.count(&#39;you&#39;)
2

# title,lower
&gt;&gt;&gt; a.title()
&#39;Hello Tom! How Are You? Are You Ok?&#39;
&gt;&gt;&gt; a.lower()
&#39;hello tom! how are you? are you ok?&#39;
&gt;&gt;&gt; a.strip(&#39;?&#39;)
&#39;Hello Tom! How are you? Are you ok&#39;

# split/partition
&gt;&gt;&gt; a.split(&#39;you&#39;)
[&#39;Hello Tom! How are &#39;, &#39;? Are &#39;, &#39; ok?&#39;]
&gt;&gt;&gt; a.partition(&#39;you&#39;)
(&#39;Hello Tom! How are &#39;, &#39;you&#39;, &#39;? Are you ok?&#39;)

# startswith
&gt;&gt;&gt; a.startswith(&quot;Hello&quot;)
True
&gt;&gt;&gt; a.startswith(&quot;You&quot;)
False

# isalpha
&gt;&gt;&gt; a.isa
a.isalnum(  a.isalpha(  a.isascii(
&gt;&gt;&gt; a.isalpha()
False

# 下标索引
&gt;&gt;&gt; a[0]
&#39;H&#39;
# 切片
&gt;&gt;&gt; a[0:3]
&#39;Hel&#39;

# in,not in
&gt;&gt;&gt; a=&quot;123&quot;
&gt;&gt;&gt; &#39;1&#39; in a
True
&gt;&gt;&gt; &#39;b&#39; in a
False

# index,count
&gt;&gt;&gt; a.index(&#39;2&#39;)
1
&gt;&gt;&gt; a.count(&#39;2&#39;)
1
</code></pre>
<h3 id="header-22">tuple</h3>
<p><code>(item1,item2,...)</code>:</p>
<ul>
<li>元素可以是不同类型的，可重复值，可嵌套 ( 与列表类似，不同之处在于元组创建后就不能修改 )</li>
<li>访问元素：<code>xxx[index]</code>，index从0开始</li>
<li>修改元素：不能修改元素，会抛出异常</li>
<li>查找元素：<code>index(item,start=0, stop=9223372036854775807)</code> 返回index，左闭右开 [start,end)，找不到抛出异常</li>
<li>查找某元素个数: <code>count(item)</code></li>
<li>可由元组,列表,字典(只取keys),集合,字符串创建元组: <code>tuple(s)</code></li>
<li>注：<ul>
<li>tuple所谓的“不变”是指tuple的每个元素指向不变</li>
<li>只有1个元素的tuple定义时须加一个逗号<code>,</code>，来消除歧义,eg:<code>a=(1,)</code></li>
</ul>
</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># tuple：元素可以是不同类型的，可重复值
&gt;&gt;&gt; a=(123,12.4,&#39;Hello&#39;,(&#39;a&#39;,&#39;b&#39;),[1,2,3],&#39;Hello&#39;)

# len
&gt;&gt;&gt; len(a)
6

# 访问元素：xxx[index]，index从0开始
&gt;&gt;&gt; a[0]
123

# 修改元素：不能修改元素，会抛出异常
&gt;&gt;&gt; a[1]=&#39;abc&#39;
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;tuple&#39; object does not support item assignment

# 注：tuple所谓的“不变”是指tuple的每个元素指向不变
&gt;&gt;&gt; a[4]
[1, 2, 3]
&gt;&gt;&gt; a[4][1]=&quot;a&quot;        # 变的不是tuple的元素，而是list的元素
&gt;&gt;&gt; a
(123, 12.4, &#39;Hello&#39;, (&#39;a&#39;, &#39;b&#39;), [1, &#39;a&#39;, 3], &#39;Hello&#39;)

# 查找元素：index(item,start,end) 返回index，左闭右开 [start,end)，找不到抛出异常
&gt;&gt;&gt; a.index(&#39;Hello&#39;,2,6)
2
&gt;&gt;&gt; a.index(&#39;Hello&#39;,3,6)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: tuple.index(x): x not in tuple

# 查找元素个数: count(item)
&gt;&gt;&gt; a.count(&#39;Hello&#39;)
2
&gt;&gt;&gt; a.count([1,2,3])
1

# tuple(s): 由元组,列表,字典(只取keys),集合,字符串创建元组
&gt;&gt;&gt; tuple((1,2,3))
(1,2,3)
&gt;&gt;&gt; tuple([1,2,3])
(1,2,3)
&gt;&gt;&gt; tuple({&#39;a&#39;:1,&#39;b&#39;:2})
(&#39;a&#39;, &#39;b&#39;)
&gt;&gt;&gt; tuple({1, 23.0, &#39;ef&#39;})
(1, 23.0, &#39;ef&#39;)
&gt;&gt;&gt; tuple(&#39;123&#39;)
(&#39;1&#39;, &#39;2&#39;, &#39;3&#39;)

# 注：只有1个元素的tuple定义时必须加一个逗号,，来消除歧义
&gt;&gt;&gt; a=(1)
&gt;&gt;&gt; type(a)
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; a=(1,)
&gt;&gt;&gt; type(a)
&lt;class &#39;tuple&#39;&gt;
&gt;&gt;&gt;
</code></pre>
<h3 id="header-23">list</h3>
<p><code>[item1,item2,...]</code>:</p>
<ul>
<li>元素可以是不同类型的，可重复值，可嵌套 ( 与元组类似，不同之处在于元组是不可变的，不能修改 )</li>
<li>访问/修改元素：<ul>
<li><code>xxx[index]</code> </li>
<li><code>xxx[index]=value</code> </li>
<li>注：index从0开始</li>
</ul>
</li>
<li>查找：<ul>
<li><code>index(item,start=0, stop=9223372036854775807)</code> 返回index，左闭右开 [start,end)，找不到抛出异常</li>
<li>查找某元素个数: <code>count(item)</code> </li>
<li>是否存在某元素：<code>item in xxx</code>, <code>item not in xxx</code><ul>
<li>添加元素：</li>
</ul>
<ul>
<li><code>append(item)</code></li>
<li><code>extend([item1,item2,...])</code></li>
<li><code>insert(index,item)</code></li>
</ul>
<ul>
<li>删除元素：</li>
</ul>
<ul>
<li><code>del xxx[index]</code></li>
<li><code>pop(index=-1)</code></li>
<li><code>remove(item)</code> 不能存在要移除元素，则会抛出异常</li>
</ul>
<ul>
<li>排序：</li>
</ul>
<ul>
<li><code>sort(reverse=False)</code></li>
<li><code>reverse()</code></li>
</ul>
</li>
</ul>
</li>
<li>可由元组,列表,字典(只取keys),集合,字符串创建list: <code>list(s)</code></li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 
a=[123,12.4,&#39;Hello&#39;,(&#39;a&#39;,&#39;b&#39;),[1,2,3],&#39;Hello&#39;]

# len
&gt;&gt;&gt; len(a)
6

# 访问元素: xxx[index] index从0开始
&gt;&gt;&gt; a[0]
123
&gt;&gt;&gt; a[2]
&#39;Hello&#39;
&gt;&gt;&gt; a[2][0]
&#39;H&#39;
&gt;&gt;&gt; a[3]
(&#39;a&#39;, &#39;b&#39;)
&gt;&gt;&gt; a[3][0]
&#39;a&#39;
&gt;&gt;&gt; a[4]
[1, 2, 3]
&gt;&gt;&gt; a[4][1]
2

# 修改元素: xxx[index]=value
&gt;&gt;&gt; a[2]=&quot;Tom&quot;
&gt;&gt;&gt; a
[123, 12.4, &#39;Tom&#39;, (&#39;a&#39;, &#39;b&#39;), [1, 2, 3], &#39;Hello&#39;]

# 查找元素：index,count
&gt;&gt;&gt; a.index(&#39;Tom&#39;)
2
&gt;&gt;&gt; a.count(&#39;Hello&#39;)
1

# 是否存在某元素：in,not in
&gt;&gt;&gt; &#39;Tom&#39; in a
True
&gt;&gt;&gt; 2 in a
False
&gt;&gt;&gt; (&#39;a&#39;,&#39;b&#39;) in a
True
&gt;&gt;&gt; &#39;Hi&#39; not in a
True

# 添加元素: append(x),extend([...]),insert(index,x)
a = [5, 4, 2, 3]
&gt;&gt;&gt; a.append(1)            # [5, 4, 2, 3, 1]
&gt;&gt;&gt; a.extend([2,8])        # [5, 4, 2, 3, 1, 2, 8]
&gt;&gt;&gt; a.insert(0,7)        # [7, 5, 4, 2, 3, 1, 2, 8]
&gt;&gt;&gt; a.insert(-1,&#39;Tom&#39;)    # [7, 5, 4, 2, 3, 1, 2, &#39;Tom&#39;, 8]

# 删除元素: del xxxx[index] , pop(index=-1), remove(item)
&gt;&gt;&gt; a=[]
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; a
[5, 4, 2, 3, 1, 2, &#39;Tom&#39;, 8]

&gt;&gt;&gt; a.pop()
8
&gt;&gt;&gt; a
[5, 4, 2, 3, 1, 2, &#39;Tom&#39;]
&gt;&gt;&gt; a.pop(4)
1
&gt;&gt;&gt; a
[5, 4, 2, 3, 2, &#39;Tom&#39;]

&gt;&gt;&gt; a.remove(&#39;Tom&#39;)
&gt;&gt;&gt; a
[5, 4, 2, 3, 2]
&gt;&gt;&gt; remove(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;remove&#39; is not defined

# 排序: sort reverse
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[2, 2, 3, 4, 5]
&gt;&gt;&gt; a.sort(reverse=True)
&gt;&gt;&gt; a
[5, 4, 3, 2, 2]

&gt;&gt;&gt; a.reverse()
&gt;&gt;&gt; a
[2, 2, 3, 4, 5]

# list(s): 可由元组,列表,字典(只取keys),集合,字符串创建
&gt;&gt;&gt; list([1,2,3])
[1,2,3]
&gt;&gt;&gt; list((1,2,3))
[1,2,3]
&gt;&gt;&gt; list({&#39;a&#39;:1,&#39;b&#39;:2})
[&#39;a&#39;, &#39;b&#39;]
&gt;&gt;&gt; list(&#39;123&#39;)
[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]
&gt;&gt;&gt; list(set([1,2,3]))
[1,2,3]
</code></pre>
<h3 id="header-24">set</h3>
<p><code>{key1,key2,...}</code>:</p>
<ul>
<li>无不可重复元素，可以是不同类型的，可嵌套</li>
<li>注：不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”</li>
<li>添加元素： <ul>
<li><code>add(key)</code></li>
<li><code>update(iterable)</code></li>
</ul>
</li>
<li>删除元素：<ul>
<li><code>remove(key)</code> 找不到会报错</li>
<li><code>discard(key)</code> 找不到不会报错</li>
<li><code>pop()</code></li>
</ul>
</li>
<li>判断是否存在某元素: <ul>
<li><code>item in s1</code></li>
<li><code>item not in s1</code></li>
</ul>
</li>
<li>交,并,差,补集：<ul>
<li>交集: <code>s1&amp;s2</code>,<code>s1.intersection(s2)</code>,<code>s1.intersection_update(s2)</code>–取交集并更新自己</li>
<li>并集: <code>s1|s2</code>,<code>s1.union(s2)</code></li>
<li>差集: <code>s1-s2</code>,<code>s1.differenc(s2)</code>,<code>s1.difference_update(s2)</code> (注：s1-s2!=s2-s1)</li>
<li>补集: <code>s1^s2</code>,<code>s1.symmetric_difference(s2)</code>, <code>s1.symmetric_difference_update(s2)</code></li>
</ul>
</li>
<li>关系判断：相交不相交, 包含不包含<ul>
<li>是否不相交 <code>s1.isdisjoint(s2)</code></li>
<li>是否包含某集合 <code>s1.issuperset(s2)</code>,<code>s1&gt;=s2</code></li>
<li>是否被某集合包含 <code>s1.issubset(s2)</code>,<code>s1&lt;=s2</code></li>
</ul>
</li>
<li>不变集合: <code>frozenset(s)</code> </li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python">&gt;&gt;&gt; s1={1,5,9,3,9}
&gt;&gt;&gt; len(s1)
4
&gt;&gt;&gt; s1
{1, 3, 5, 9}

# 注：不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”
&gt;&gt;&gt; s2={1,2,(1,2)}
&gt;&gt;&gt; s2
{(1, 2), 1, 2}

&gt;&gt;&gt; s2={1,2,[1,2]}
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unhashable type: &#39;list&#39;

# 添加元素 add(key),update(iterable)
&gt;&gt;&gt; s1.add(2)
&gt;&gt;&gt; s1
{1, 2, 3, 5, 9}
&gt;&gt;&gt; s1.add(&#39;Tom&#39;)
&gt;&gt;&gt; s1
{1, 2, 3, 5, 9, &#39;Tom&#39;} 
&gt;&gt;&gt; s1.add(9)
&gt;&gt;&gt; s1
{1, 2, 3, 5, 9}

&gt;&gt;&gt; s1.update({7,10})
&gt;&gt;&gt; s1
{1, 2, 3, 5, 7, 9, 10}
&gt;&gt;&gt; s1.update([1,4])
&gt;&gt;&gt; s1
{1, 2, 3, 4, 5, 7, 9, 10}
&gt;&gt;&gt; s1.update(&#39;ef&#39;)
&gt;&gt;&gt; s1
{1, 2, 3, 4, 5, 7, 9, 10, &#39;f&#39;, &#39;e&#39;}
&gt;&gt;&gt; s1.update(9)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;int&#39; object is not iterable

# 删除元素 remove(key),discard(key)--不会报错,pop()
&gt;&gt;&gt; s1.remove(&#39;Tom&#39;)
&gt;&gt;&gt; s1
{1, 2, 3, 5, 9}
&gt;&gt;&gt; s1.remove(&#39;a&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#39;a&#39; 

&gt;&gt;&gt; s1.discard(&#39;a&#39;)

&gt;&gt;&gt; s1.pop()
1
&gt;&gt;&gt; s1
{2, 3, 5, 9, &#39;Tom&#39;}

# 判断是否存在某元素: in,not in
&gt;&gt;&gt; s1
{2, 3, 5, 9, &#39;Tom&#39;}
&gt;&gt;&gt; 5 in s1
True
&gt;&gt;&gt; 7 not in s1
True
&gt;&gt;&gt; 1 in s1
False

# 交,并,差,补集
&gt;&gt;&gt; s1={1,5,6,9}
&gt;&gt;&gt; s2={3,5,9,10}

&gt;&gt;&gt; s1&amp;s2     # 交集 s1.intersection(s2), s1.intersection_update(s2) -- 取交集并更新自己
{9, 5}

&gt;&gt;&gt; s1|s2      # 并集 s1.union(s2)
{1, 3, 5, 6, 9, 10}

&gt;&gt;&gt; s1-s2     # 差集 differenc,difference_update
{1, 6}
&gt;&gt;&gt; s2-s1
{10, 3}

&gt;&gt;&gt; s1^s2    # 补集 symmetric_difference, symmetric_difference_update
{1, 3, 6, 10}

# 关系判断：相交不相交，包含不包含
&gt;&gt;&gt; s1.isdisjoint(s2)     # 是否不相交
False
&gt;&gt;&gt; {1,3}.isdisjoint({2,5})
True

&gt;&gt;&gt; s1.issuperset(s2)  # 是否包含某集合（a&gt;=b）
False
&gt;&gt;&gt; {1,3,5}.issuperset({3,5})
True 
&gt;&gt;&gt; {1,3,5} &gt;= {3,5}

&gt;&gt;&gt; s1.issubset(s2)    # 是否被包含 （a&lt;=b）
False
&gt;&gt;&gt; {3,5}.issubset({1,3,5})
True
&gt;&gt;&gt; {3,5}&lt;={1,3,5}
True

# frozenset 不变集合
&gt;&gt;&gt; a=frozenset({1,3,5})
&gt;&gt;&gt; a
frozenset({1, 3, 5})
&gt;&gt;&gt; a.add(4)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39;

# set(s): 可由元组,列表,字典(只取keys),集合,字符串创建
&gt;&gt;&gt; set((1,2,3))
{1,2,3}

&gt;&gt;&gt; set({1,2,3})
{1,2,3}

&gt;&gt;&gt; set([1,2,2,3,1,2])
{1,2,3}

&gt;&gt;&gt; set({&#39;a&#39;:1,&#39;b&#39;:2})
{&#39;a&#39;, &#39;b&#39;}

&gt;&gt;&gt; set(&#39;123&#39;)
{&#39;2&#39;, &#39;3&#39;, &#39;1&#39;}
</code></pre>
<h3 id="header-25">dict</h3>
<p><code>{key1:value1,key2:value2,...}</code>:</p>
<ul>
<li><code>key:value</code> 键值对，key需为不可改变类型，如int,float,str,tuple</li>
<li>访问元素: <ul>
<li><code>xxx[key]</code></li>
<li><code>.get(key,default=None)</code></li>
</ul>
</li>
<li>更新／添加元素: <ul>
<li><code>xxx[key]=value</code></li>
<li><code>.update({key:value,...})</code></li>
<li><code>.setdefault(key,default=None)</code></li>
</ul>
</li>
<li>删除元素:<ul>
<li><code>del xxx[key]</code></li>
<li><code>.pop(key)</code></li>
<li><code>.popitem()</code></li>
<li><code>.clear()</code></li>
</ul>
</li>
<li>获取对象<ul>
<li><code>keys()</code> 返回一个包含所有KEY的列表</li>
<li><code>values()</code> 返回一个包含所有value的列表</li>
<li><code>items()</code> 返回一个元组列表 <code>[(key,value),...]</code></li>
</ul>
</li>
<li>判断是非存在某key:<ul>
<li><code>key in d</code></li>
<li><code>key not in d</code></li>
</ul>
</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python">&gt;&gt;&gt; d={&#39;a&#39;:1,&#39;b&#39;:2}
&gt;&gt;&gt; len(d)
2

# 访问元素: xxxx[key],xxx.get(key,default=None)
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d[&#39;b&#39;]
2
&gt;&gt;&gt; d.get(&#39;a&#39;)
1
&gt;&gt;&gt; d.get(&#39;c&#39;,&#39;N/A&#39;)
&#39;N/A&#39;

# 更新／插入元素: xxx[key]=value,.update({...}),.setdefault(key,default=None)
&gt;&gt;&gt; d[&#39;a&#39;]=&#39;123&#39;
&gt;&gt;&gt; d[&#39;c&#39;]=789
&gt;&gt;&gt; d[&#39;e&#39;]=(1,2)
&gt;&gt;&gt; d
{&#39;a&#39;: &#39;123&#39;, &#39;b&#39;: 2, &#39;c&#39;: 789, &#39;e&#39;: (1, 2)}

&gt;&gt;&gt; d.update({&#39;b&#39;:&#39;Hello&#39;,&#39;f&#39;:&#39;Tom&#39;})
&gt;&gt;&gt; d
{&#39;a&#39;: &#39;123&#39;, &#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;e&#39;: (1, 2), &#39;f&#39;: &#39;Tom&#39;}

&gt;&gt;&gt; d.setdefault(&#39;a&#39;,99)
&#39;123&#39;
&gt;&gt;&gt; d
{&#39;a&#39;: &#39;123&#39;, &#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;e&#39;: (1, 2), &#39;f&#39;: &#39;Tom&#39;}
&gt;&gt;&gt; d.setdefault(&#39;g&#39;,99)
99
&gt;&gt;&gt; d
{&#39;a&#39;: &#39;123&#39;, &#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;e&#39;: (1, 2), &#39;f&#39;: &#39;Tom&#39;, &#39;g&#39;: 99}

# 删除元素: del xxx[key],pop(key),popitem(),clear()
&gt;&gt;&gt; del d[&#39;e&#39;]
&gt;&gt;&gt; d
{&#39;a&#39;: &#39;123&#39;, &#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;f&#39;: &#39;Tom&#39;, &#39;g&#39;: 99}
&gt;&gt;&gt; d.pop(&#39;a&#39;)
&#39;123&#39;
&gt;&gt;&gt; d
{&#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;f&#39;: &#39;Tom&#39;, &#39;g&#39;: 99}

&gt;&gt;&gt; d.popitem()
(&#39;g&#39;, 99)
&gt;&gt;&gt; d
{&#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;f&#39;: &#39;Tom&#39;}

# keys
&gt;&gt;&gt; d.keys()
dict_keys([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
# values
dict_values([&#39;123&#39;, 2, 789])
# items
&gt;&gt;&gt; d.items()
dict_items([(&#39;a&#39;, &#39;123&#39;), (&#39;b&#39;, 2), (&#39;c&#39;, 789)])

# 判断key是否存在：key in d, key not in d
&gt;&gt;&gt; &#39;c&#39; in d
True
&gt;&gt;&gt; &#39;g&#39; in d
False
&gt;&gt;&gt; &#39;a&#39; not in d
True
&gt;&gt;&gt; d.setdefault(&#39;k&#39;)
&gt;&gt;&gt; d
{&#39;b&#39;: &#39;Hello&#39;, &#39;c&#39;: 789, &#39;f&#39;: &#39;Tom&#39;, &#39;k&#39;: None}
&gt;&gt;&gt; &#39;k&#39; in d
True
</code></pre>
<h2 id="header-26">函数</h2>
<pre><code class="lang-python">def test1():
    pass

def test2(step=1)
    print(&quot;step=%s&quot; % step)

def test3()
    return [1,2,3]
</code></pre>
<pre><code class="lang-bash">&gt;&gt;&gt; test1()
&gt;&gt;&gt; test2(5)
step=5
&gt;&gt;&gt; test3()
[1,2,3]
</code></pre>
<h3 id="header-27">作用域</h3>
<ul>
<li>局部变量: <ul>
<li>在函数内部定义的变量，只能在本函数中用</li>
<li>可使用</li>
</ul>
</li>
<li>全局变量: <ul>
<li>在函数外定义的变量</li>
<li>使用：可以在所有的函数中使用</li>
<li>修改：在函数中不能修改全局变量的指向<ul>
<li>可变类型的全局变量 =&gt; 其指向的数据直接可以修改</li>
<li>不可类型的全局变量 =&gt; 使用global声明后可修改</li>
</ul>
</li>
</ul>
</li>
<li>注：<ul>
<li>可使用<code>globals()</code>、<code>locals()</code>列出当前作用域中所有全局／局部变量</li>
<li>函数中同名变量，局部变量优先全局变量</li>
<li>实际上，Python使用<code>LEGB顺序</code>规则来查找一个符号对应的对象<pre><code>  Locals（局部） -&gt; Enclosing function（嵌套函数）-&gt; Globals（全局） -&gt; Builtins（Python启动时会自动载入）
</code></pre></li>
</ul>
</li>
</ul>
<p><strong>Sample1:查看全局／局部变量</strong></p>
<pre><code class="lang-python">import math
NumA=10
NumB=20
def testScope(*arg):
    a=1
    b=&#39;Hello&#39;
    print(&quot;locals:&quot;,locals())         # print 局部变量 （注：函数参数也属于locals）
    print(&quot;globals:&quot;,globals())        # print 全局变量 （注：包括python内建模块和手动import的）

&gt;&gt;&gt; testScope(&#39;Tom&#39;)
locals: {&#39;arg&#39;: (&#39;Tom&#39;,), &#39;a&#39;: 1, &#39;b&#39;: &#39;Hello&#39;}
globals: {&#39;__name__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: None, &#39;__package__&#39;: None, &#39;__loader__&#39;: &lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&gt;, &#39;__spec__&#39;: None, &#39;__annotations__&#39;: {}, &#39;__builtins__&#39;: &lt;module &#39;builtins&#39; (built-in)&gt;, &#39;NumA&#39;: 10, &#39;NumB&#39;: 20, &#39;testLocals&#39;: &lt;function testLocals at 0x10c7acf28&gt;, &#39;testScope&#39;: &lt;function testScope at 0x10c780950&gt;, &#39;math&#39;: &lt;module &#39;math&#39; from &#39;/anaconda3/lib/python3.7/lib-dynload/math.cpython-37m-darwin.so&#39;&gt;}
</code></pre>
<p><strong>Sample2: 全局／局部变量优先级</strong></p>
<pre><code class="lang-python">Num=10

# 1. 使用全局变量
def testGlobalVar(step=1):
    x=Num+step                # 使用全局变量
    print(&quot;x=%s&quot; % x)

&gt;&gt;&gt; testVar(3)
x=13

# 2. 使用局部变量
def testLocalVar(step=1):
    Num=20                    # 同名变量，局部变量优先级高于全局变量
    x=Num+step
    print(&quot;x=%s,Num=%s&quot; % (x,Num))

&gt;&gt;&gt; testVar4(3)
x=23,Num=20
&gt;&gt;&gt; Num
13
</code></pre>
<p><strong>Sample3: 修改全局变量</strong></p>
<pre><code class="lang-python"># 1. 不可变类型的全局变量
Num=10                        # 不可变类型
def testVar(step=1):
    x=Num+step
    Num=x
    print(&quot;x=%s,Num=%s&quot; % (x,Num))

&gt;&gt;&gt; testVar(3)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 2, in testVar2
UnboundLocalError: local variable &#39;Num&#39; referenced before assignment

def testVar(step=1):
    global Num                     # 使用global声明后可修改该全局变量
    x=Num+step
    Num=x
    print(&quot;x=%s,Num=%s&quot; % (x,Num))

&gt;&gt;&gt; testVar(3)
x=13,Num=13
&gt;&gt;&gt; Num                         # 全局变量Num已修改
13

# 2. 可变类型的全局变量
A=[1,2,3]
def testVar(step=1):
    A.append(step)
    print(A)

&gt;&gt;&gt; testVar(4)
[1, 2, 3, 4]
&gt;&gt;&gt; A                            # 全局变量A已修改
</code></pre>
<h3 id="header-28">函数参数</h3>
<ul>
<li>参数<ul>
<li>引用传参: 引用传递,不是值传递</li>
<li>不可变类型: 函数中运算不会影响到变量自身</li>
<li>可变类型: 函数中运算可能会影响到变量自身</li>
</ul>
</li>
<li>缺省参数(默认参数)<ul>
<li>一定要位于参数列表的最后面</li>
<li>(可在可变参数<code>*</code>前面或后面,但一定要在关键字参数<code>**</code>前面，不然会有歧义报错)</li>
</ul>
</li>
<li>不定长参数：<ul>
<li>用于处理比当初声明时更多的参数</li>
<li><code>*</code>变量：<ul>
<li>表示可变参数,tuple类型<ul>
<li>如: <code>*args</code> ，args用tuple存放未命名的变量参数</li>
<li>可直接传入,也可先组装list或tuple，再通过<code>*</code>传入,如：<code>func(*(1, 2, 3))</code></li>
</ul>
</li>
</ul>
</li>
<li><code>**</code>变量：<ul>
<li>表示关键字参数,dict类型,可以限制传入的参数名，同时提供默认值</li>
<li>如: <code>**kwargs</code>，kwargs用dict存放命名的参数(即key=value的参数)</li>
<li>可直接传入,也可先组装dict，再通过<code>**</code>传入,如：<code>func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})</code></li>
<li>有<code>*</code>变量时，需在<code>*</code>变量后面（即最后面）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Sample1:传入不可变／可变参数</strong></p>
<pre><code class="lang-python"># 1. 传入不可变参数
def testArg(a,b):
    # a=a+b
    a+=b
    print(&quot;a=%s&quot; % a)

&gt;&gt;&gt; a,b=3,5
&gt;&gt;&gt; testArg(a,b)
a=8
&gt;&gt;&gt; a                     # a 未变
3

# 2. 传入可变参数
def testArg(a,b):
    a.append(b)
    print(&#39;a=%s&#39; % a)

&gt;&gt;&gt; a,b=[1,2,3],4
&gt;&gt;&gt; testArg(a,b)
a=[1, 2, 3, 4]
&gt;&gt;&gt; a                  # a 变了
[1, 2, 3, 4]
</code></pre>
<p><strong>Sample2: 缺省参数(默认参数)</strong></p>
<pre><code class="lang-python"># 1. 单个缺省参数
def testArg(a,b=1):
    print(&#39;a=%s,b=%s,a+b=%s&#39; % (a,b,a+b))

&gt;&gt;&gt; testArg(3,5)
a=3,b=5,a+b=8
&gt;&gt;&gt; testArg(3)
a=3,b=1,a+b=4

# 2.多个缺省参数(位于参数列表的最后面)
def testArg(a,b=1,c=None,d=&#39;abc&#39;):
    print(&#39;a=%s,b=%s,c=%s,d=%s&#39; % (a,b,c,d))

&gt;&gt;&gt; testArg(1,2,3,4)
a=1,b=2,c=3,d=4
&gt;&gt;&gt; testArg(1,2,3)
a=1,b=2,c=3,d=abc
&gt;&gt;&gt; testArg(1,2)
a=1,b=2,c=None,d=abc
&gt;&gt;&gt; testArg(1)
a=1,b=1,c=None,d=abc
&gt;&gt;&gt; testArg(1,d=5,c=4)         # 指定传入参数
a=1,b=1,c=4,d=5
&gt;&gt;&gt; testArg(1,[2,3])        # 传入可变参数
a=1,b=[2, 3],c=None,d=abc
</code></pre>
<p><strong>Sample3: 不定长参数</strong></p>
<pre><code class="lang-python"># 1. *arg,**kwargs
def testArg(a,b,*args,**kwargs):
    print(&quot;a=%s,b=%s,args=%s,kwargs=%s&quot; % (a,b,args,kwargs))

&gt;&gt;&gt; testArg(1,2)
a=1,b=2,args=(),kwargs={}

&gt;&gt;&gt; testArg(1,2,3,4,x=&#39;001&#39;,y=&#39;002&#39;)    # 直接传入
a=1,b=2,args=(3, 4),kwargs={&#39;x&#39;: &#39;001&#39;, &#39;y&#39;: &#39;002&#39;}

&gt;&gt;&gt; m=(7,8,9)
&gt;&gt;&gt; n={&#39;k&#39;:&#39;005&#39;,&#39;z&#39;:&#39;006&#39;}

&gt;&gt;&gt; testArg(1,2,m,n)
a=1,b=2,args=((7, 8, 9), {&#39;k&#39;: &#39;005&#39;, &#39;z&#39;: &#39;006&#39;}),kwargs={}

&gt;&gt;&gt; testArg(1,2,*m,**n)                    # 组装后传入
a=1,b=2,args=(7, 8, 9),kwargs={&#39;k&#39;: &#39;005&#39;, &#39;z&#39;: &#39;006&#39;}

&gt;&gt;&gt; testArg(1,2,3,4,*m,**n,x=&#39;001&#39;,y=&#39;002&#39;)
a=1,b=2,args=(3, 4, 7, 8, 9),kwargs={&#39;k&#39;: &#39;005&#39;, &#39;z&#39;: &#39;006&#39;, &#39;x&#39;: &#39;001&#39;, &#39;y&#39;: &#39;002&#39;}

&gt;&gt;&gt; testArg(1,2,3,4,*m,**n,x=&#39;001&#39;,z=&#39;002&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: testArg() got multiple values for keyword argument &#39;z&#39;

# 2. + default arg
def testArg(a,b,c=&#39;abc&#39;,*args,**kwargs):    # 或 def testArg(a,b,*args,c=&#39;abc&#39;,**kwargs):
    print(&quot;a=%s,b=%s,c=%s,args=%s,kwargs=%s&quot; % (a,b,c,args,kwargs))

&gt;&gt;&gt; testArg(1,2)
a=1,b=2,c=abc,args=(),kwargs={}
&gt;&gt;&gt; testArg(1,2,3,x=&#39;001&#39;,y=&#39;002&#39;)
a=1,b=2,c=3,args=(),kwargs={&#39;x&#39;: &#39;001&#39;, &#39;y&#39;: &#39;002&#39;}
&gt;&gt;&gt; testArg(1,2,3,4,x=&#39;001&#39;,y=&#39;002&#39;)
a=1,b=2,c=3,args=(4,),kwargs={&#39;x&#39;: &#39;001&#39;, &#39;y&#39;: &#39;002&#39;}
&gt;&gt;&gt; testArg(1,2,x=&#39;001&#39;,y=&#39;002&#39;,c=4)
a=1,b=2,c=4,args=(),kwargs={&#39;x&#39;: &#39;001&#39;, &#39;y&#39;: &#39;002&#39;}

&gt;&gt;&gt; testArg(1,2,5,c=4,x=&#39;001&#39;,y=&#39;002&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: testArg() got multiple values for argument &#39;c&#39;
</code></pre>
<h3 id="header-29">函数返回值</h3>
<ul>
<li>无返回值</li>
<li>返回一个变量,eg: <code>return x</code></li>
<li>返回多个变量,eg: <code>return x,y</code> 本质是返回了一个元组</li>
<li>注意：变量也可以代表函数，所以也可返回函数</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 1. 无返回值
def testReturn(a,b):
    print(&quot;a+b=%s&quot; % (a+b))

&gt;&gt;&gt; testReturn(1,3)
a+b=4

# 2. 返回一个变量
def testReturn(a,b):
    return a+b

&gt;&gt;&gt; testReturn(1,3)
4
&gt;&gt;&gt; testReturn([1,2],[3,4])
[1, 2, 3, 4]

# 3. 返回多个变量
def testReturn(a,b):
    return a,b,a+b

&gt;&gt;&gt; testReturn(2,3)
(2, 3, 5)

&gt;&gt;&gt; a,b,c=testReturn(2,3)
&gt;&gt;&gt; a,b,c
(2, 3, 5)
&gt;&gt;&gt; a
2
&gt;&gt;&gt; b
3
&gt;&gt;&gt; c
5

&gt;&gt;&gt; a,b,c=testReturn([1,2],[3,4])
&gt;&gt;&gt; a,b,c
([1, 2], [3, 4], [1, 2, 3, 4])

# 4. 返回函数
def testReturn(a,b):
    def test_in(c):
        return a+b+c
    return test_in

&gt;&gt;&gt; f=testReturn(3,5)
&gt;&gt;&gt; f
&gt;&gt;&gt; f(1)
9
&gt;&gt;&gt; f(2)
10
</code></pre>
<h3 id="header-30">高级特性：闭包</h3>
<ul>
<li>返回内部函数，内部函数使用了外部包裹函数作用域里变量（非全局变量），则称内部函数为闭包</li>
<li>优点：<ul>
<li>可提高代码可复用性</li>
<li>似优化了变量，原来需要类对象完成的工作，闭包也可以完成</li>
</ul>
</li>
<li>缺点：<ul>
<li>由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存</li>
</ul>
</li>
</ul>
<p><strong>Sample1:闭包</strong></p>
<pre><code class="lang-python">def test(a):
    def test_in(b):
        print(&quot;a=%s,b=%s,a+b=%s&quot; % (a,b,a+b))
        return a+b
    return test_in

&gt;&gt;&gt; f=test(3)
&gt;&gt;&gt; f
&lt;function test.&lt;locals&gt;.test_in at 0x107af51e0&gt;

&gt;&gt;&gt; f(5)
a=3,b=5,a+b=8
8
&gt;&gt;&gt; f(8)
a=3,b=8,a+b=11
11
</code></pre>
<p><strong>Sample2:返回一个计数器</strong></p>
<pre><code class="lang-python">def counter(start=0):
    global total
    total=start
    def incr():
        total+=1                # total相对于incr()为外部变量，且为不可变类型，修改会报错
        return total
    return incr

&gt;&gt;&gt; ct1=counter()
&gt;&gt;&gt; a,b,c=ct1(),ct1(),ct1()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;&lt;stdin&gt;&quot;, line 4, in incr
UnboundLocalError: local variable &#39;total&#39; referenced before assignment

# solution1: 使用可变型变量
def counter(start=0):
    total=[start]
    def incr():
        total[0] += 1
        return total[0]
    return incr

# solution2: 使用nonlocal声明
def counter(start=0):
    total=start
    def incr():
        nonlocal total
        total+=1
        return total
    return incr

# 或者：
def counter(start=0):
    def incr():
        nonlocal start
        start+=1
        return start
    return incr


# test:
&gt;&gt;&gt; ct1=counter()
&gt;&gt;&gt; ct2=counter(5)
&gt;&gt;&gt; a,b,c=ct1(),ct1(),ct1()
&gt;&gt;&gt; a,b,c
&gt;&gt;&gt; (1,2,3)
&gt;&gt;&gt; x,y,z=ct2(),ct2(),ct2()
&gt;&gt;&gt; x,y,z
(6, 7, 8)
</code></pre>
<h3 id="header-31">高级特性: 列表生成式</h3>
<p>List Comprehensions： <code>[]</code> 列表生成式即用来创建list的生成式</p>
<pre><code class="lang-python"># 
&gt;&gt;&gt; list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]

&gt;&gt;&gt; d = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }
&gt;&gt;&gt; [k+&#39;=&#39;+v for k, v in d.items()]
[&#39;y=B&#39;, &#39;x=A&#39;, &#39;z=C&#39;]
</code></pre>
<h3 id="header-32">高级特性：生成器(generator)</h3>
<ul>
<li>生成器: 一个不断产生值的函数,边计算边产出值</li>
<li>生成过程： 每次迭代从上一次返回时的函数体中的位置开始，所使用的参数都是第一次所保留下的,不是新创建的（生成器“记住”了数据状态和流程中的位置）</li>
<li>相比一次列出所有内容的优势: 节约内存，响应迅速，使用灵活</li>
<li>创建生成器：<ul>
<li>使用包含<code>yield</code>语句的函数, 生成器每调用一次，会在yield位置产生一个值, 直到函数执行结束</li>
<li>简单的生成器，可以通过将一个列表生成式的 <code>[ ]</code> 改成 <code>( )</code>直接生成</li>
</ul>
</li>
<li>获取生成器生成的元素：<ul>
<li>通过<code>next(g)</code>函数获得生成器的下一个返回值<ul>
<li>没有更多的元素时，抛出 <code>StopIteration</code> 的异常</li>
<li>生成器函数的返回值包含在StopIteration的value中，可通过捕获StopIteration错误获取返回值</li>
</ul>
</li>
<li>通过<code>for in</code> 循环<ul>
<li>没有更多的元素时，不会抛出 <code>StopIteration</code> 的异常</li>
<li>拿不到生成器函数的返回值（return语句的返回值）</li>
</ul>
</li>
<li>注：生成器中元素都取出后就无用了</li>
</ul>
</li>
</ul>
<p><strong>Sample1:</strong></p>
<pre><code class="lang-python"># 1. 普通函数: 一次列出所有（如果n=100M,1000M,...会很慢）
def double(n):
    return [i*2 for i in range(1,n)]

# 2. 生成器函数: 用多少生成多少，效率高（更节约内存和快捷）
def gen(n):
    for i in range(1,n):
        yield i*2

# 3. 创建生成器，下面g1与g2效果相同
g1 = gen(5)
g2 = (x*2 for x in range(1,5))

&gt;&gt;&gt; g1
&lt;generator object &lt;genexpr&gt; at 0x1114b1e58&gt;
&gt;&gt;&gt; g2

# 4. 获取生成器生成的元素
# Method1: 使用`next(g)`函数
&gt;&gt;&gt; next(g1)
2
&gt;&gt;&gt; next(g1)
4
&gt;&gt;&gt; next(g1)
8
&gt;&gt;&gt; next(g1)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-51-e734f8aca5ac&gt; in &lt;module&gt;
----&gt; 1 next(g)

StopIteration:

# Method2: 使用`for in g`循环遍历
for i in g2:
...:     print(i,&quot; &quot;,end=&quot;&quot;)
...:
2 4 6 8
</code></pre>
<p><strong>Sample2:</strong></p>
<pre><code class="lang-python"># 1. 定义生成器函数
def odd():
    print(&#39;step 1&#39;)
    yield 1
    print(&#39;step 2&#39;)
    yield(3)
    print(&#39;step 3&#39;)
    yield(5)
    return &quot;no more&quot;

# 2. 定义遍历生成器函数
def getAll_by_forin(g):
    for i in g:
        print(i)

def getAll_by_next(g):
    while True:
        try:
            print(&#39;x=%s&#39; % next(g))
        except StopIteration as e:
            print(&#39;Generator return value:&#39;, e.value)
            break
    print(&#39;finish!&#39;)

# test1: 使用 for in 循环
&gt;&gt;&gt; g1=odd()
&gt;&gt;&gt; getAll_by_forin(g1)
step 1
1
step 2
3
step 3
5

# test2: 使用 next(g) 
&gt;&gt;&gt; g2=odd()
&gt;&gt;&gt; getAll_by_next(g1)
tep 1
x=1
step 2
x=3
step 3
x=5
Generator return value: no more
finish!
</code></pre>
<h3 id="header-33">高级特性：迭代器(Iterator)</h3>
<ul>
<li>迭代器（Iterator）对象:<ul>
<li>可以被<code>next()</code>函数调用并不断返回下一个值的对象(直到没有数据时抛出<code>StopIteration</code>错误)</li>
<li><code>Iterator</code>对象表示的是一个惰性计算（即只有在需要获取下一个数据时它才会计算）的序列(即数据流，可以无限大，如全体自然数)</li>
<li>如：生成器generator对象</li>
</ul>
</li>
<li>可迭代对象（Iterable）:<ul>
<li>可以直接作用于<code>for in</code>循环的对象</li>
<li>如: list、tuple、dict、set、str,generator</li>
</ul>
</li>
<li>迭代器<code>Iterator</code>对象一定是可迭代对象<code>Iterable</code>(可以用<code>for in</code>循环)，反之不一定</li>
<li>可使用<code>iter()</code>函数将<code>Iterable</code>对象转换为<code>Iterator</code>对象</li>
<li>可以使用<code>isinstance()</code>判断一个对象类型，如：判断是否是<code>Iterable</code>对象，是否是<code>Iterator</code>对象</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python">import collections

# 1. list,tuple,dict,set,str等是`Iterable`对象但不是`Iterator`对象
&gt;&gt;&gt; l=[1,2,3]
&gt;&gt;&gt; isinstance(l,Iterable)
True
&gt;&gt;&gt; isinstance(l,Iterator)
False
&gt;&gt;&gt; next(l)
next(l)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-79-cdc8a39da60d&gt; in &lt;module&gt;
----&gt; 1 next(l)

TypeError: &#39;list&#39; object is not an iterator

&gt;&gt;&gt; for i in l:
...:     print(i)
...:
1
2
3

# 2. 使用`iter(x)`函数将`Iterable`对象转换为`Iterator`对象
&gt;&gt;&gt; a=iter(l)
&gt;&gt;&gt; isinstance(a,Iterable)
True
&gt;&gt;&gt; isinstance(a,Iterator)
True
&gt;&gt;&gt; next(a)
1
&gt;&gt;&gt; next(a)
2

# 3. generator对象是`Iterator`对象
&gt;&gt;&gt; g=(x*2 for x in range(1,5))
&gt;&gt;&gt; isinstance(l,Iterable)
True
&gt;&gt;&gt; isinstance(l,Iterator)
True
&gt;&gt;&gt; next(g)
2
&gt;&gt;&gt; next(g)
4
</code></pre>
<h3 id="header-34">高级特性：装饰器(decorator)</h3>
<ul>
<li>增强函数功能（例如在函数调用前后自动打印日志），但不修改函数原本定义</li>
<li>本质上，decorator就是一个返回函数的高阶函数</li>
</ul>
<p><strong>Sample:</strong></p>
<ol>
<li><p>原始函数特性</p>
<pre><code class="lang-python"> def sum(a,b):
     print(&quot;a+b=%s&quot; % (a+b))

 # 查看函数名字`__name__`
 &gt;&gt;&gt; dir(sum)
 [&#39;__annotations__&#39;, &#39;__call__&#39;, &#39;__class__&#39;, &#39;__closure__&#39;, &#39;__code__&#39;, &#39;__defaults__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__get__&#39;, &#39;__getattribute__&#39;, &#39;__globals__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__kwdefaults__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;]
 &gt;&gt;&gt; sum.__name__
 &#39;sum&#39;
 &gt;&gt;&gt; f=sum
 &gt;&gt;&gt; f.__name__
 &#39;sum&#39;

 &gt;&gt;&gt; sum(3,5)
 a+b=8
 &gt;&gt;&gt; f(3,5)
 a+b=8
</code></pre>
</li>
<li><p>定义使用一个无参decorator</p>
<pre><code class="lang-python"> # 1. 定义decorator：log
 def log(func):
     def func_wrapper(*args, **kw):
         print(&#39;call %s(%s,%s):&#39; % (func.__name__,args,kw))
         return func(*args, **kw)
     return func_wrapper

 # 2. 在原函数上加上decorator: 使用`@`
 # 把`@log`放到`sum()`函数的定义处，相当于执行了:`sum = log(sum)`
 @log
 def sum(a,b):
     print(&quot;a+b=%s&quot; % (a+b))

 # 3. test:
 &gt;&gt;&gt; sum(3,5)
 call sum((3, 5),{}):
 a+b=8
 &gt;&gt;&gt; sum.__name__
 &#39;func_wrapper&#39;
</code></pre>
</li>
<li><p>定义使用一个有参decorator</p>
<pre><code class="lang-python"> # 1. 定义decorator：log （decorator本身传入参数，需返回一个decorator的高阶函数）
 def log(text):
     def log_wrapper(func):
         def func_wrapper(*args, **kw):
             print(&#39;%s %s(%s,%s):&#39; % (text,func.__name__,args,kw))
             return func(*args, **kw)
         return func_wrapper
     return log_wrapper

 # 2. 使用decorator
 # 相当于执行了: `sum = log(&#39;execute:&#39;)(sum)`
 @log(&#39;execute:&#39;)
 def sum(a,b):
     print(&quot;a+b=%s&quot; % (a+b))

 # 3. test:
 &gt;&gt;&gt; sum(3,5)
 execute: sum((3, 5),{}):
 a+b=8
 &gt;&gt;&gt; sum.__name__
 &#39;func_wrapper&#39;
</code></pre>
</li>
<li><p>Issue: 被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变）,eg: 装饰后的函数<code>__name__</code>等不准确了</p>
<pre><code class="lang-python"> # 需要把原始函数的`__name__`等属性复制到`func_wraper()`函数
 # 可使用functools.wraps(function)装饰器来消除这样的副作用

 import functools

 def log(text):
     def log_wrapper(func):
         @functools.wraps(func)     # 添加functools.wraps(function)装饰器
         def func_wrapper(*args, **kw):
             print(&#39;%s %s(%s,%s):&#39; % (text,func.__name__,args,kw))
             return func(*args, **kw)
         return func_wrapper
     return log_wrapper

 @log(&#39;execute:&#39;)
 def sum(a,b):
     print(&quot;a+b=%s&quot; % (a+b))

 # test:
 &gt;&gt;&gt; sum(3,5)
 execute: sum((3, 5),{}):
 a+b=8
 &gt;&gt;&gt; sum.__name__
 &#39;sum&#39;
</code></pre>
</li>
</ol>
<h3 id="header-35">匿名函数</h3>
<ul>
<li>lambda函数：<code>lambda [arg1 [,arg2,.....argn]]:expression</code><ul>
<li><code>冒号</code>前面的表示函数参数，可以无参</li>
<li>只能有一个<code>表达式</code>，不用写<code>return</code>，返回值就是该表达式的结果</li>
</ul>
</li>
<li>应用: 函数作为参数,返回值传递</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 1. lambda函数
&gt;&gt;&gt; sum=lambda a,b:a+b         # 相当于 def sum(a,b): return a+b
&gt;&gt;&gt; sum
&lt;function &lt;lambda&gt; at 0x10787c158&gt;
&gt;&gt;&gt; sum(3,5)
8

# 2. 应用: 作为参数
&gt;&gt;&gt; a=[3,1,5]
&gt;&gt;&gt; a.sort()
&gt;&gt;&gt; a
[1, 3, 5]

&gt;&gt;&gt; a=[
... {&#39;name&#39;:&#39;Tom&#39;,&#39;age&#39;:18}
... ,{&#39;name&#39;:&#39;Lucy&#39;,&#39;age&#39;:22}
... ,{&#39;name&#39;:&#39;Andy&#39;,&#39;age&#39;:20}
... ]
&gt;&gt;&gt; a.sort()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;&lt;&#39; not supported between instances of &#39;dict&#39; and &#39;dict&#39;

&gt;&gt;&gt; k=lambda item:item[&#39;name&#39;]
&gt;&gt;&gt; a.sort(key=k)
&gt;&gt;&gt; a
[{&#39;name&#39;: &#39;Andy&#39;, &#39;age&#39;: 20}, {&#39;name&#39;: &#39;Lucy&#39;, &#39;age&#39;: 22}, {&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 18}]

&gt;&gt;&gt; a.sort(key=lambda x:x[&#39;age&#39;])
&gt;&gt;&gt; a
[{&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 18}, {&#39;name&#39;: &#39;Andy&#39;, &#39;age&#39;: 20}, {&#39;name&#39;: &#39;Lucy&#39;, &#39;age&#39;: 22}]
</code></pre>
<h3 id="header-36">内建函数</h3>
<p>Build-in Function</p>
<ul>
<li>python解释器启动后默认加载</li>
<li>查看：<code>dir(__builtins__)</code></li>
<li>使用：<code>help(function)</code></li>
<li><p>常用的内建函数</p>
<ul>
<li><code>range(stop)</code>, <code>range(start stop[, step])</code> -&gt; integer list  (默认start=0,不包括stop,使用了惰性计算)<pre><code class="lang-python">  &gt;&gt;&gt; a = range(5)
  &gt;&gt;&gt; a 
  range(0, 5)
  &gt;&gt;&gt; list(a)
  [0, 1, 2, 3, 4]
  &gt;&gt;&gt; [x*2 for x in a]
  [0, 2, 4, 6, 8]
</code></pre>
</li>
<li><p><code>map(func, *iterables)</code> 根据提供的函数对指定序列做映射(使用了惰性计算)</p>
<pre><code class="lang-python">  &gt;&gt;&gt; a=[1,2,3]
  &gt;&gt;&gt; b=map(lambda x:x*x,a)
  &gt;&gt;&gt; list(b)
  [1, 4, 9]

  &gt;&gt;&gt; c=map(lambda x,y:(x,y),[1,2,3],[&#39;a,&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])
  &gt;&gt;&gt; list(c)
  [(1, &#39;a,&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]

  &gt;&gt;&gt; d=map(str,[1,2,3,&#39;a&#39;])
  &gt;&gt;&gt; list(d)
  [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;a&#39;]

  &gt;&gt;&gt; t=map(str,(1,2,3,&#39;a&#39;))
  &gt;&gt;&gt; tuple(t)
  (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;a&#39;)
</code></pre>
</li>
<li><p><code>filter(function or None, iterable)</code> 从一个序列中筛出符合条件的元素(使用了惰性计算，所以只有在取<code>filter()</code>结果的时候,才会真正筛选并每次返回下一个筛出的元素)</p>
<pre><code class="lang-python">  &gt;&gt;&gt; a=filter(lambda x:x%2,[1,2,3,4])    # 参数 function 返回1／0 =&gt; 布尔值True/False
  &gt;&gt;&gt; list(a)
  [1, 3]

  &gt;&gt;&gt; b=filter(lambda x:x%2,{1,2,3,4})
  &gt;&gt;&gt; set(b)
  {1, 3}
</code></pre>
</li>
<li><p><code>sorted(iterable, cmp=None, key=None, reverse=False)</code>  -&gt; new sorted object</p>
<pre><code class="lang-python">  &gt;&gt;&gt; a=sorted([1,5,4,2,9])
  &gt;&gt;&gt; a
  [1, 2, 4, 5, 9]

  &gt;&gt;&gt; a=[{&#39;name&#39;:&#39;Tom&#39;,&#39;age&#39;:18},{&#39;name&#39;:&#39;Lucy&#39;,&#39;age&#39;:22},{&#39;name&#39;:&#39;Andy&#39;,&#39;age&#39;:20}]
  &gt;&gt;&gt; result=sorted(a,key=lambda x:x[&#39;age&#39;])
  &gt;&gt;&gt; result
  [{&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 18}, {&#39;name&#39;: &#39;Andy&#39;, &#39;age&#39;: 20}, {&#39;name&#39;: &#39;Lucy&#39;, &#39;age&#39;: 22}]
</code></pre>
</li>
</ul>
</li>
<li><p><code>functools</code> 工具函数包</p>
<pre><code class="lang-python">  &gt;&gt;&gt; import functools
  &gt;&gt;&gt; dir(functools)
  [&#39;RLock&#39;, &#39;WRAPPER_ASSIGNMENTS&#39;, &#39;WRAPPER_UPDATES&#39;, &#39;_CacheInfo&#39;, &#39;_HashedSeq&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;_c3_merge&#39;, &#39;_c3_mro&#39;, &#39;_compose_mro&#39;, &#39;_convert&#39;, &#39;_find_impl&#39;, &#39;_ge_from_gt&#39;, &#39;_ge_from_le&#39;, &#39;_ge_from_lt&#39;, &#39;_gt_from_ge&#39;, &#39;_gt_from_le&#39;, &#39;_gt_from_lt&#39;, &#39;_le_from_ge&#39;, &#39;_le_from_gt&#39;, &#39;_le_from_lt&#39;, &#39;_lru_cache_wrapper&#39;, &#39;_lt_from_ge&#39;, &#39;_lt_from_gt&#39;, &#39;_lt_from_le&#39;, &#39;_make_key&#39;, &#39;cmp_to_key&#39;, &#39;get_cache_token&#39;, &#39;lru_cache&#39;, &#39;namedtuple&#39;, &#39;partial&#39;, &#39;partialmethod&#39;, &#39;recursive_repr&#39;, &#39;reduce&#39;, &#39;singledispatch&#39;, &#39;total_ordering&#39;, &#39;update_wrapper&#39;, &#39;wraps&#39;]
</code></pre>
<ul>
<li><p><code>reduce(function, sequence[, initial])</code> -&gt; value</p>
<pre><code class="lang-python">  &gt;&gt;&gt; a=functools.reduce(lambda x, y: x+y, [1,2,3,4])
  &gt;&gt;&gt; a
  10

  &gt;&gt;&gt; a=functools.reduce(lambda x, y: x+y, [1,2,3,4],10)
  &gt;&gt;&gt; a
  20
</code></pre>
</li>
<li><p><code>partial(func, *args, **keywords)</code> 偏函数:简化func,设置默认值 -&gt; new function 这样调用这个新函数会更简单</p>
<pre><code class="lang-python">  &gt;&gt;&gt; int2 = functools.partial(int, base=2)
  &gt;&gt;&gt; int2(&#39;1000000&#39;)            # 等同：int(&#39;1000000&#39;,base=2)
  64

  &gt;&gt;&gt; def showarg(*args, **kw):
  ...     print(&quot;args=%s,kw=%s&quot; % (args,kw))
  ...
  &gt;&gt;&gt; f=functools.partial(showarg, 1,2,3,a=3,b=&#39;linux&#39;)
  &gt;&gt;&gt; f()
  args=(1, 2, 3),kw={&#39;a&#39;: 3, &#39;b&#39;: &#39;linux&#39;}
  &gt;&gt;&gt; f(4,5,c=&#39;hello&#39;)
  args=(1, 2, 3, 4, 5),kw={&#39;a&#39;: 3, &#39;b&#39;: &#39;linux&#39;, &#39;c&#39;: &#39;hello&#39;}
</code></pre>
</li>
<li><p><code>wraps(func)</code>装饰器: 消除被装饰函数的函数名等函数属性发生改变的副作用</p>
<pre><code class="lang-python">  def note(func):
      &quot;note function&quot;
      @functools.wraps(func)
      def func_wrapper(*args,**kw):
          &quot;wrapper function&quot;
          print(&#39;call %s(%s,%s):&#39; % (func.__name__,args,kw))
          return func(*args,*kw)
      return func_wrapper

  @note
  def test(a,b):
      &#39;test function&#39;
      print(&#39;a=%s,b=%s&#39; % (a,b))

  &gt;&gt;&gt; test(3,5)
  call test((3, 5),{}):
  a=3,b=5
  &gt;&gt;&gt; test.__name__
  &#39;test&#39;
  &gt;&gt;&gt; test.__doc__
  &#39;test function&#39;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="header-37">类与实例</h2>
<pre><code class="lang-python">class Cat:            # 定义类
    pass

&gt;&gt;&gt; c=Cat()            # 创建实例

# 1. 类对象
&gt;&gt;&gt; Cat             
__main__.Cat
&gt;&gt;&gt; type(Cat)
type

# 2. 实例对象
&gt;&gt;&gt; c                 
&lt;__main__.Cat at 0x104f875f8&gt;
&gt;&gt;&gt; type(c)
__main__.Cat
</code></pre>
<ol>
<li><p>类对象与实例对象</p>
<ul>
<li>类对象(class) : 模版</li>
<li>实例对象(instance) : 根据类创建的对象</li>
<li>获取对象信息：<ul>
<li><code>type(x)</code> : 获取对象类型</li>
<li><code>isinstance(x,class_or_tuple)</code> : 判断class的类型</li>
<li><code>dir(x)</code> : 查看一个对象的所有属性和方法(包括私有)</li>
</ul>
</li>
</ul>
</li>
<li><p>特性：</p>
<ul>
<li>类的三大特性：封装，继承，多态 （注：python类不仅支持单继承，还支持多继承）</li>
<li>python是动态语言，可动态给类／对象增删改属性和方法<ul>
<li>增/改：<code>类／实例对象.xxx=...</code></li>
<li>删除：<code>del 类／实例对象.xxx</code>,<code>delattr(类／实例对象,name)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>访问限制</p>
<ul>
<li>公有: 默认</li>
<li>保护：以<code>_</code>开头，自己内部和子类可访问，不能用<code>from module import *</code>导入(即不可跨包)</li>
<li>私有: 以<code>__</code>开头，只有自己内部可以访问，外部（包括子类，实例对象等）不能访问</li>
<li>注：<ul>
<li>一般将属性私有化，以防止外部随意访问修改</li>
<li>可通过编写<code>getXxx/setXxx</code>方法或<code>@property</code>控制对外开放接口</li>
</ul>
</li>
</ul>
</li>
<li><p>访问</p>
<ul>
<li>属性／方法： <code>类.xxx</code>,<code>实例.xxx</code></li>
<li>方法调用：<code>类.xxx(...)</code>,<code>实例.xxx(...)</code></li>
<li>python也提供了内置函数判断获取对象属性或方法（无法判断或调用私有属性／方法）<ul>
<li><code>getattr(obj,name)</code></li>
<li><code>setattr(obj,name,value)</code></li>
<li><code>hasattr(obj,name)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-38">类成员：属性</h3>
<pre><code class="lang-python">class Cat:
    name=&#39;cls_cat&#39;                # 类属性
    def __init__(self):
        self.age=1                # 实例属性

c=Cat()

&gt;&gt;&gt; Cat.name,c.name
(&#39;cls_cat&#39;, &#39;cls_cat&#39;)

&gt;&gt;&gt; c.name=&#39;self_cat&#39;            # 添加同名实例属性
&gt;&gt;&gt; Cat.name,c.name             # 实例属性会屏蔽掉同名的类属性
(&#39;cls_cat&#39;, &#39;self_cat&#39;)

&gt;&gt;&gt; del c.name                     # 删除实例属性
&gt;&gt;&gt; Cat.name,c.name
(&#39;cls_cat&#39;, &#39;cls_cat&#39;)

&gt;&gt;&gt; c.age
1
</code></pre>
<ul>
<li>类属性：<ul>
<li>类所有，所有实例共享一个属性，在内存中只存在一个副本</li>
<li>在类外访问：可通过类和实例对象访问公有类属性 <code>类名.xxx</code>,<code>实例名.xxx</code></li>
<li>在类外添加：<code>类名.xxx=...</code></li>
</ul>
</li>
<li>实例属性：<ul>
<li>实例所有，各个实例各自维护，互不影响</li>
<li>在类外访问：通过实例对象访问 <code>实例名.xxx</code></li>
<li>在类外添加：<code>实例名.xxx=...</code></li>
</ul>
</li>
<li>注： 使用<code>实例名.xxx</code>访问属性时，先找实例属性，没有再找类属性，所以：<ul>
<li>类属性和实例属性同名，用<code>实例名.xxx</code>访问时,实例属性会屏蔽掉同名的类属性</li>
<li>在类外修改类属性，必须通过类对象（如果通过实例对象，会产生一个同名的实例属性）</li>
</ul>
</li>
<li>高级<ul>
<li>属性私有化： 一般将属性私有化，以防止外部随意访问修改<ul>
<li>法一：编写<code>getXxx/setXxx</code>方法</li>
<li>法二：使用<code>@property</code>标示为属性函数(即将一个方法变成属性调用)</li>
</ul>
</li>
<li>限制动态添加实例属性： <ul>
<li>定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</li>
<li>用<code>tuple</code>定义允许绑定的属性名称: <code>__slots__=(...)</code></li>
<li>注: <code>__slots__</code>仅对当前类实例起作用，对继承的子类无用,除非在子类中也定义，这样子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Sample1: 属性私有化</strong></p>
<ul>
<li><p>法一：编写<code>getXxx/setXxx</code>方法开放端口</p>
<pre><code class="lang-python">  class Cat:
      def __init__(self):
          self.__age=0

      def getAge(self):
          return self.__age

      def setAge(self,value):
          if not isinstance(value, int):
              raise ValueError(&#39;age must be an integer!&#39;)
          if value &lt; 0 or value &gt; 100:
              raise ValueError(&#39;age must between 0 ~ 100!&#39;)
          self.__age = value

  c=Cat()

  &gt;&gt;&gt; c.age
  --------------------------------------------------------------------------
  AttributeError                            Traceback (most recent call last)
  &lt;ipython-input-257-4dd7fde137b3&gt; in &lt;module&gt;
  ----&gt; 1 c.age

  AttributeError: &#39;Cat&#39; object has no attribute &#39;age&#39;

  &gt;&gt;&gt; c.setAge(3)
  &gt;&gt;&gt; c.getAge()
  3
</code></pre>
</li>
<li><p>法二：使用<code>@property</code>标示为属性函数</p>
<pre><code class="lang-python">  class Cat:
      def __init__(self):
          self.__age=0

      @property                     # getter
      def age(self):
          return self.__age

      @age.setter                 # setter
      def age(self,value):
          if not isinstance(value, int):
              raise ValueError(&#39;age must be an integer!&#39;)
          if value &lt; 0 or value &gt; 100:
              raise ValueError(&#39;age must between 0 ~ 100!&#39;)
          self.__age = value

  c=Cat()

  &gt;&gt;&gt; c.age＝5
  &gt;&gt;&gt; c.age
  5
</code></pre>
</li>
</ul>
<p><strong>Sample2:限制动态添加实例属性</strong></p>
<pre><code class="lang-python">class Cat:
    __slots__=(&#39;name&#39;,&#39;age&#39;)     # 用tuple定义允许绑定的属性名称

class ColorfulCat(Cat):
    pass

class PureCat(Cat):
    __slots__=(&#39;color&#39;)

# 1. test 父：Cat
&gt;&gt;&gt; c=Cat()                      # 父类实例对象 -- 只允许属性：name,age
&gt;&gt;&gt; c.name=&#39;Tom&#39;
&gt;&gt;&gt; c.age=3
&gt;&gt;&gt; c.country=&#39;China&#39;
c.country=&quot;China&quot;
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-269-64570eaae7be&gt; in &lt;module&gt;
----&gt; 1 c.country=&quot;China&quot;

AttributeError: &#39;Cat&#39; object has no attribute &#39;country&#39;

# 2. test 子：ColorfulCat
&gt;&gt;&gt; e=ColorfulCat()                # 子类实例对象－－无限制
&gt;&gt;&gt; e.name=&#39;Tom&#39;
&gt;&gt;&gt; e.name
&#39;Tom&#39;
&gt;&gt;&gt; e.country=&#39;China&#39;    
&gt;&gt;&gt; e.country
&#39;China&#39;

# 3. test 子：PureCat
&gt;&gt;&gt; p=PureCat()                 # 子类实例对象－－允许属性：父(name,age)＋ 子(color)
&gt;&gt;&gt; p.color=&#39;White&#39;
&gt;&gt;&gt; p.name=&#39;Tom&#39;
&gt;&gt;&gt; p.age=1
&gt;&gt;&gt; p.country=&#39;China&#39;
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
&lt;ipython-input-281-3661a6a00d34&gt; in &lt;module&gt;
----&gt; 1 p.country=&#39;China&#39;

AttributeError: &#39;PureCat&#39; object has no attribute &#39;country&#39;
</code></pre>
<h3 id="header-39">类成员：方法</h3>
<pre><code class="lang-python">class Cat:
    name=&#39;cls_cat&#39;

    def eat(self):                # 实例方法
        print(&#39;%s is eating&#39; % self.name)

    @classmethod
    def from_setting(cls):        # 类方法
        cls.name=&#39;cls_cat_fresh&#39;
        # 可添加类方法（第一个参数代表类）:
        @classmethod
        def say_cls(x,y):
            return &quot;%s say %s&quot; % (x.name,y)
        cls.say_cls=say_cls
        # 可添加实例方法（第一个参数代表实例）:
        cls.say_self=lambda x,y:&quot;%s say %s&quot; % (x.name,y)

    @staticmethod                 # 静态方法
    def play():
        print(&quot;%s is playing&quot; % Cat.name)

c=Cat()

&gt;&gt;&gt; Cat.name,c.name
(&#39;cls_cat&#39;, &#39;cls_cat&#39;)

# 1. 调用类方法
&gt;&gt;&gt; Cat.from_setting()          # or use: c.from_setting()
&gt;&gt;&gt; Cat.name,c.name
(&#39;cls_cat_fresh&#39;, &#39;cls_cat_fresh&#39;)

# 2. 调用静态方法
&gt;&gt;&gt; Cat.play()                 # or use: c.play()
cls_cat_fresh is playing

# 3. 调用实例方法
&gt;&gt;&gt; c.eat()                 # can&#39;t use: Cat.eat()
cls_cat_fresh is eating
&gt;&gt;&gt; c.name=&#39;self_cat&#39;
&gt;&gt;&gt; c.eat()
self_cat is eating

# 4. 调用from_setting()后添加的方法
&gt;&gt;&gt; c.say_self(&#39;Hello&#39;) 
&#39;self_cat say Hello&#39;
&gt;&gt;&gt; c.say_cls(&#39;Hello&#39;)
&#39;cls_cat_fresh say Hello&#39;
</code></pre>
<ul>
<li>类方法:<ul>
<li>需用修饰器<code>@classmethod</code>标识,第一个参数(习惯用变量名<code>cls</code>)必须是类对象（类外调用时，不用传递该参数，Python解释器会自己把类对象传入）</li>
<li>方法中：可修改类定义</li>
<li>在类外访问：可通过实例和类访问 <code>类名.xxx(...)</code>,<code>实例名.xxx(...)</code></li>
</ul>
</li>
<li>实例方法：<ul>
<li>不用修饰，第一参数(习惯用变量名<code>self</code>)必须是实例对象本身（类外调用时，不用传递该参数，Python解释器会自己把实例对象传入）</li>
<li>方法中：可修改实例属性（eg: <code>self.xxx</code>)</li>
<li>在类外访问：通过实例访问<code>实例名.xxx(...)</code> （不可使用类访问）</li>
</ul>
</li>
<li>静态方法：<ul>
<li>需用修饰器<code>@staticmethod</code>标识,无参数限制</li>
<li>方法中：可通过类调用类属性,类方法,静态方法 <code>类名.xxx</code>,<code>类名.xxx(...)</code></li>
<li>在类外调用：可通过实例和类访问 <code>类名.xxx(...)</code>,<code>实例名.xxx(...)</code></li>
</ul>
</li>
</ul>
<h3 id="header-40">继承与多态</h3>
<ul>
<li><p>继承：</p>
<ul>
<li>子类创建过程：<ul>
<li>子类<code>__new__</code>，无则调用父类 <code>__new__</code></li>
<li>子类<code>__init__</code>，无则父类 <code>__init__</code></li>
</ul>
</li>
<li>父类使用了有参<code>__init__</code>，则子类创建时也要有参</li>
<li>子类无法访问父类的私有属性和方法</li>
<li>重写: 子类会覆盖父类中同名的方法<ul>
<li>子类中调用父类方法<code>super().xxx</code>,<code>父类.xxx</code></li>
<li><code>类.__mro__</code> 可以查看类搜索方法时的先后顺序</li>
</ul>
</li>
</ul>
</li>
<li><p>单继承</p>
<pre><code class="lang-python">  class Animal:
      def eat(self):
          print(&#39;eating...&#39;)

  class Cat(Animal):
      pass
</code></pre>
</li>
<li><p>多继承(MixIn)</p>
<pre><code class="lang-python">  class Runnable:
      def run(self):
          print(&#39;runing...&#39;)

  class Cat(Animal,Runnable):
      pass
</code></pre>
</li>
<li><p>多态：自动调用实际类型的方法</p>
</li>
</ul>
<p><strong>Sample1:继承</strong></p>
<pre><code class="lang-python">class Animal:
    def __init__(self,name):
        self.name=name
        print(&quot;Animal %s init.&quot; % name)

    def eat(self):
        print(&#39;Animal is eating...&#39;)

class Cat(Animal):

    def eat(self):
        print(&quot;Cat is eating...&quot;)

    def play(self):
        print(&quot;Cat is playing...&quot;)

    def father(self):
        print(&quot;call father eat func:&quot;)
        super().eat()
        print(&quot;call self eat func:&quot;)
        self.eat()

&gt;&gt;&gt; c=Cat(&quot;Tom&quot;)
Animal Tom init.

&gt;&gt;&gt; c.eat()
Cat is eating...

&gt;&gt;&gt; c.play()
Cat is playing... 

&gt;&gt;&gt; c.father()
call father eat func:
Animal is eating...
call self eat func:
Cat is eating...

&gt;&gt;&gt; Cat.__mro__
(__main__.Cat, __main__.Animal, object)

&gt;&gt;&gt; isinstance(c,Cat)
True
&gt;&gt;&gt; isinstance(c,Animal)
True
</code></pre>
<p><strong>Sample2:多态</strong></p>
<pre><code class="lang-python">class Animal:
    def eat():
        print(&#39;Animal is eating...&#39;)

class Cat(Animal):
    def eat():
        print(&quot;Cat is eating...&quot;)

class Dog(Animal):
    def eat():
        print(&quot;Dog is eating...&quot;)

def do_eat(obj):
    obj.eat()

&gt;&gt;&gt; do_eat(Animal())
Animal is eating...

&gt;&gt;&gt; do_eat(Cat())
Cat is eating...

&gt;&gt;&gt; do_eat(Dog())
Dog is eating...
</code></pre>
<h3 id="header-41">高阶：元类metaclass</h3>
<ul>
<li>类拥有创建实例对象的能力，而类本身也是对象，可动态地创建（Python是动态语言，函数和类，不是编译时定义的，而是运行时动态创建的）</li>
<li>元类即用来创建类的“东西”，实现方式：<ul>
<li>直接使用<code>type</code>元类</li>
<li>自定义一个元类：创建一个函数或类，使用<code>class</code>关键字或<code>type(...)</code>创建类</li>
</ul>
</li>
<li><code>type(object_or_name, bases, dict)</code>: Python内建的可以用来创建所有类的元类<ul>
<li>type(object) -&gt; the object’s type 查看某个对象的类型</li>
<li>type(name, bases, dict) -&gt; a new type 创建一个新的类型<ul>
<li>name: 类名，str</li>
<li>bases: 父类名，tuple</li>
<li>dict: 类属性，成员方法，dict</li>
</ul>
</li>
</ul>
</li>
<li><p><code>metaclass</code>/<code>__metaclass__</code>: 类定义时指定元类</p>
<pre><code class="lang-python">  # metaclass元类查找顺序：Foo -&gt; Bar -&gt; Module -&gt; type

  # 1. python2写法:
  class Foo(Bar):        
      __metaclass__=xxx
      pass

  # 2. python3写法:
  class Foo(Bar,metaclass=xxx):
      pass
</code></pre>
<ul>
<li><code>metaclass=函数／类</code>，参数同<code>type</code>：name, bases, dict</li>
<li>应用：创建类时动态修改类定义（元类：拦截类的创建 -&gt; 修改类 -&gt; 返回修改之后的类）<ul>
<li>例如：ORM框架，一个类对应一个表，类／实例对象操作对应数据库表／记录操作</li>
</ul>
</li>
<li>Python会使用当前类中<code>metaclass</code>指定的元类创造类对象，没有则找父类的，父类没有则去模块层次中找，还找不到则用内置的<code>type</code>来创建这个类对象</li>
</ul>
</li>
</ul>
<p><strong>Sample1: 使用元类<code>type</code>创建类</strong></p>
<pre><code class="lang-python">def eat(self):
    print(&#39;Cat is eating...&#39;)

&gt;&gt;&gt; cls=type(&#39;Cat&#39;,(),{&#39;name&#39;:&#39;Cat&#39;,&#39;age&#39;:1,&#39;eat&#39;:eat})
&gt;&gt;&gt; cls.name,cls.age
(&#39;Cat&#39;,1)

&gt;&gt;&gt; c=cls()
&gt;&gt;&gt; c.name=&#39;Tom&#39;
&gt;&gt;&gt; cls.name,c.name
 (&#39;Cat&#39;, &#39;Tom&#39;)

&gt;&gt;&gt; c.eat()
Cat is eating...
</code></pre>
<p><strong>Sample2: 自定义一个函数作为元类来创建类</strong></p>
<pre><code class="lang-python"># 自定义一个函数，使用`class`关键字创建类（也可使用`type`创建类）
def choose_animal(name):
    if name==&#39;Cat&#39;:
        class Cat:
            def eat(self):
                print(&quot;Cat is eating...&quot;)
        return Cat
    else:
        class Animal:
            def eat(self):
                print(&#39;Animal is eating...&#39;)
        return Animal

&gt;&gt;&gt; cls=choose_animal(&#39;Cat&#39;)    # __main__.choose_animal.&lt;locals&gt;.Cat
&gt;&gt;&gt; c=cls()                     # &lt;__main__.choose_animal.&lt;locals&gt;.Cat at 0x1050e7ac8&gt;
&gt;&gt;&gt; c.eat()
Cat is eating...
</code></pre>
<p><strong>Sample3:通过<code>__metaclass__</code>属性指定元类，动态改变类定义</strong></p>
<pre><code class="lang-python"># 1. 自定义一个元类
# 使用函数
def animalMetaCls(clsName,bases,attrs):
    print(&#39;call animalMetaCls&#39;,clsName)
    if clsName==&#39;Cat&#39;:
        def eat(self):
            print(&#39;Cat is eating...&#39;)
        attrs[&#39;eat&#39;]=eat
        attrs[&#39;name&#39;]=&#39;Cat&#39;
    return type(clsName,bases,attrs)

# 或使用类
class animalMetaCls:
    def __new__(cls,clsName,bases,attrs):
        print(&#39;call animalMetaCls&#39;,clsName)
        if clsName==&#39;Cat&#39;:
            def eat(self):
                print(&#39;Cat is eating...&#39;)
            attrs[&#39;eat&#39;]=eat
            attrs[&#39;name&#39;]=&#39;Cat&#39;
        return type(clsName,bases,attrs)

# 2. 通过metaclass指定元类
&gt;&gt;&gt; class Cat(metaclass=animalMetaCls):
...     pass
...
call animalMetaCls Cat                 # 创建类时，就会触发metaclass

# 3. verify:
&gt;&gt;&gt; c=Cat()
&gt;&gt;&gt; c.eat()
Cat is eating...
&gt;&gt;&gt; Cat.name
&#39;Cat&#39;
</code></pre>
<h3 id="header-42">高阶：枚举类Enum</h3>
<p>Refer <a href="https://docs.python.org/3/library/enum.html" target="_blank" rel="noopener">Doc</a></p>
<ul>
<li>可以把一组相关常量定义在一个class中，class不可变，成员可以等值比较</li>
<li><code>Enum(value, names=None, *, module=None, qualname=None, type=None, start=1)</code><ul>
<li>value: What the new Enum class will record as its name.</li>
<li>names: The Enum members. This can be a whitespace or comma separated string (values will start at 1 unless otherwise specified)<ul>
<li><code>&#39;RED GREEN BLUE&#39; | &#39;RED,GREEN,BLUE&#39; | &#39;RED, GREEN, BLUE&#39;</code></li>
<li><code>[&#39;RED&#39;, &#39;GREEN&#39;, &#39;BLUE&#39;]</code></li>
<li><code>[(&#39;CYAN&#39;, 4), (&#39;MAGENTA&#39;, 5), (&#39;YELLOW&#39;, 6)]</code></li>
<li><code>{&#39;CHARTREUSE&#39;: 7, &#39;SEA_GREEN&#39;: 11, &#39;ROSEMARY&#39;: 42}</code></li>
</ul>
</li>
<li>module: name of module where new Enum class can be found.</li>
<li>qualname: where in module new Enum class can be found.</li>
<li>type: type to mix in to new Enum class</li>
<li>start: number to start counting at if only names are passed i</li>
</ul>
</li>
<li>注：Enum的value属性是自动赋给成员的int常量，默认从1开始计数</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python">from enum import Enum,auto

# 1.创建枚举类对象

# 法一：直接使用`Enum(变量统称名，(变量1，变量2....))`
Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))

# 法二：继承自Enum类
@unique                     # optional: @unique装饰器--检查保证没有重复值
class Month(Enum):
    Jan=1
    Feb=auto()
    Mar=auto()
    Apr=auto()
    May=auto()
    Jun=auto()
    Jul=auto()
    Aug=auto()
    Sep=auto()
    Oct=auto()
    Nov=auto()
    Dec=auto()

# 2. test:
&gt;&gt;&gt; Month
&lt;enum &#39;Month&#39;&gt;
&gt;&gt;&gt; type(Month)
enum.EnumMeta

&gt;&gt;&gt; Month.Feb                         # 枚举
&lt;Month.Feb: 2&gt;
&gt;&gt;&gt; type(Month.Feb)
&lt;enum &#39;Month&#39;&gt;

&gt;&gt;&gt; Month.Feb.name                     # 获取枚举名
&#39;Feb&#39;
&gt;&gt;&gt; Month.Feb.value                 # 获取枚举名
2
&gt;&gt;&gt; Month[&#39;Feb&#39;]                     # 获取枚举名为&#39;Feb&#39;的枚举，返回枚举类型
&lt;Month.Feb: 2&gt; 
&gt;&gt;&gt; Month(2)                         # 获取枚举值为2的枚举，返回枚举类型
&lt;Month.Feb: 2&gt;

&gt;&gt;&gt; Month.Feb==Month.Feb             # 枚举等值比较（注：无法直接进行大小比较）
True
&gt;&gt;&gt; Month.Feb!=Month.Jan
True
&gt;&gt;&gt; Month.Feb is Month.Jan
False

&gt;&gt;&gt; for item in Month:                 # 遍历枚举，列出所有枚举成员
...     print(item)
Month.Jan
Month.Feb
Month.Mar
Month.Apr
Month.May
Month.Jun
Month.Jul
Month.Aug
Month.Sep
Month.Oct
Month.Nov
Month.Dec

&gt;&gt;&gt; list(Month)
[&lt;Month.Jan: 1&gt;,
 &lt;Month.Feb: 2&gt;,
 &lt;Month.Mar: 3&gt;,
 &lt;Month.Apr: 4&gt;,
 &lt;Month.May: 5&gt;,
 &lt;Month.Jun: 6&gt;,
 &lt;Month.Jul: 7&gt;,
 &lt;Month.Aug: 8&gt;,
 &lt;Month.Sep: 9&gt;,
 &lt;Month.Oct: 10&gt;,
 &lt;Month.Nov: 11&gt;,
 &lt;Month.Dec: 12&gt;]

&gt;&gt;&gt; Month.__members__                     # __members__
mappingproxy({&#39;Jan&#39;: &lt;Month.Jan: 1&gt;,
              &#39;Feb&#39;: &lt;Month.Feb: 2&gt;,
              &#39;Mar&#39;: &lt;Month.Mar: 3&gt;,
              &#39;Apr&#39;: &lt;Month.Apr: 4&gt;,
              &#39;May&#39;: &lt;Month.May: 5&gt;,
              &#39;Jun&#39;: &lt;Month.Jun: 6&gt;,
              &#39;Jul&#39;: &lt;Month.Jul: 7&gt;,
              &#39;Aug&#39;: &lt;Month.Aug: 8&gt;,
              &#39;Sep&#39;: &lt;Month.Sep: 9&gt;,
              &#39;Oct&#39;: &lt;Month.Oct: 10&gt;,
              &#39;Nov&#39;: &lt;Month.Nov: 11&gt;,
              &#39;Dec&#39;: &lt;Month.Dec: 12&gt;})

&gt;&gt;&gt; Month.__members__.keys()
Out[35]: odict_keys([&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;])

&gt;&gt;&gt; Month.__members__.values()
odict_values([&lt;Month.Jan: 1&gt;, &lt;Month.Feb: 2&gt;, &lt;Month.Mar: 3&gt;, &lt;Month.Apr: 4&gt;, &lt;Month.May: 5&gt;, &lt;Month.Jun: 6&gt;, &lt;Month.Jul: 7&gt;, &lt;Month.Aug: 8&gt;, &lt;Month.Sep: 9&gt;, &lt;Month.Oct: 10&gt;, &lt;Month.Nov: 11&gt;, &lt;Month.Dec: 12&gt;])

&gt;&gt;&gt; Month.__members__.items()
Out[5]: odict_items([(&#39;Jan&#39;, &lt;Month.Jan: 1&gt;), (&#39;Feb&#39;, &lt;Month.Feb: 2&gt;), (&#39;Mar&#39;, &lt;Month.Mar: 3&gt;), (&#39;Apr&#39;, &lt;Month.Apr: 4&gt;), (&#39;May&#39;, &lt;Month.May: 5&gt;), (&#39;Jun&#39;, &lt;Month.Jun: 6&gt;), (&#39;Jul&#39;, &lt;Month.Jul: 7&gt;), (&#39;Aug&#39;, &lt;Month.Aug: 8&gt;), (&#39;Sep&#39;, &lt;Month.Sep: 9&gt;), (&#39;Oct&#39;, &lt;Month.Oct: 10&gt;), (&#39;Nov&#39;, &lt;Month.Nov: 11&gt;), (&#39;Dec&#39;, &lt;Month.Dec: 12&gt;)])

&gt;&gt;&gt; for name, member in Month.__members__.items():
...    print(name, &#39;=&gt;&#39;, member, &#39;,&#39;, member.value)
...
Jan =&gt; Month.Jan , 1
Feb =&gt; Month.Feb , 2
Mar =&gt; Month.Mar , 3
Apr =&gt; Month.Apr , 4
May =&gt; Month.May , 5
</code></pre>
<h3 id="header-43">高阶：单例模式</h3>
<p>Singleton 确保某一个类只有一个实例</p>
<pre><code class="lang-python">class Cat:
    __instance=None
    __first_init = True         # optional:用来保证只初始化一次

    def __new__(cls,name,age):
        if not cls.__instance:
            cls.__instance=object.__new__(cls)
        return cls.__instance

    def __init__(self,name,age):
        if self.__first_init:
            print(&#39;init&#39;)
            self.name=name
            self.age=age
            Cat.__first_init=False

&gt;&gt;&gt; c1=Cat(&#39;Tom&#39;,2)
init
&gt;&gt;&gt; c2=Cat(&#39;Andy&#39;,3)
&gt;&gt;&gt; c1==c2
True
&gt;&gt;&gt; id(c1),id(c2)
(4559954776, 4559954776)
&gt;&gt;&gt; c1.name,c2.name
(&#39;Tom&#39;, &#39;Tom&#39;)
</code></pre>
<p>实际<code>Enum</code>就是个单例：</p>
<pre><code class="lang-python">class Cat(Enum):
    Instance=1

&gt;&gt;&gt; c1=Cat.Instance
&gt;&gt;&gt; c2=Cat.Instance
&gt;&gt;&gt; c1==c2
True
&gt;&gt;&gt; id(c1),id(c2)
(4560045560, 4560045560)
&gt;&gt;&gt; c1.name,c2.name
(&#39;Instance&#39;, &#39;Instance&#39;)
&gt;&gt;&gt; c2.age=3
&gt;&gt;&gt; c1.age,c2.age
(3,3)
</code></pre>
<h3 id="header-44">高阶：内置类属性</h3>
<p>可通过<code>dir(obj)</code>查看某对象的所有方法和属性，eg:</p>
<pre><code class="lang-python">
class Cat:
    def eat(self):
        print(&#39;eating...&#39;)

&gt;&gt;&gt; dir(Cat)
[&#39;__class__&#39;,
 &#39;__delattr__&#39;,
 &#39;__dict__&#39;,
 &#39;__dir__&#39;,
 &#39;__doc__&#39;,
 &#39;__eq__&#39;,
 &#39;__format__&#39;,
 &#39;__ge__&#39;,
 &#39;__getattribute__&#39;,
 &#39;__gt__&#39;,
 &#39;__hash__&#39;,
 &#39;__init__&#39;,
 &#39;__init_subclass__&#39;,
 &#39;__le__&#39;,
 &#39;__lt__&#39;,
 &#39;__module__&#39;,
 &#39;__ne__&#39;,
 &#39;__new__&#39;,
 &#39;__reduce__&#39;,
 &#39;__reduce_ex__&#39;,
 &#39;__repr__&#39;,
 &#39;__setattr__&#39;,
 &#39;__sizeof__&#39;,
 &#39;__str__&#39;,
 &#39;__subclasshook__&#39;,
 &#39;__weakref__&#39;]
</code></pre>
<p>一些常用的内置类属性和方法说明：</p>
<ul>
<li>方法：<ul>
<li><code>__new__</code> 创建实例时触发调用</li>
<li><code>__init__</code> 创建实例后触发调用</li>
<li><code>__str__</code> 返回用户看到的字符串，若没实现，使用repr结果，print时调用</li>
<li><code>__repr__</code> 返回程序开发者看到的字符串（为调试服务的），直接输出时调用</li>
<li><code>__getattribute__</code> 属性访问拦截器,触发访问实例属性时</li>
</ul>
</li>
<li>属性：<ul>
<li><code>__class__</code> 实例的类,触发方式:<code>实例.__class__</code></li>
<li><code>__doc__</code> 类文档,子类不继承,触发方式: <code>help(类或实例)</code></li>
<li><code>__module__</code> 类定义所在的模块</li>
<li><code>__dict__</code> 对象的属性字典</li>
</ul>
</li>
</ul>
<pre><code class="lang-python">class Cat:
    age=1

    def __new__(cls,name):                 # 要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供
        print(&#39;new Cat %s&#39; % name)
        return object.__new__(cls)      # 返回实例化出来的实例

    def __init__(self,name):             # 参数self，就是__new__返回的实例
        self.name=name
        print(&#39;%s init.&#39; % name)     

    def __del__(self):
        print(&#39;%s del.&#39; % self.name)

    def __str__(self):
        return &quot;Cat [name=%s]&quot; % self.name

    def __getattribute__(self,attr): # 注意：不要这个方法中调用self.xxxx，会进入死循环
        print(&#39;get attr: %s&#39; % attr)
        return object.__getattribute__(self,attr) 


&gt;&gt;&gt; c=Cat(&#39;Tom&#39;)         # 触发调用 __new__ =&gt; __init__
new Cat Tom
Tom init.

&gt;&gt;&gt; c                     # 触发调用__repr__
&lt;__main__.Cat at 0x104b83208&gt;

&gt;&gt;&gt; print(c)             # 触发调用__str__
Cat [name=Tom]

&gt;&gt;&gt; c.name                 # 触发__getattribute__
get attr: name
&#39;tom&#39;

&gt;&gt;&gt; c.__class__
__main__.Cat

&gt;&gt;&gt; c.__dict__
{&#39;name&#39;: &#39;Tom&#39;}

&gt;&gt;&gt; del c                 # 触发调用__del__
Tom del.
</code></pre>
<h3 id="header-45">高阶：定制类</h3>
<p>定制类：通过在类中定义python内建的特殊方法<code>__xxx__</code>，可为类实现一些特殊的操作</p>
<p><strong>一些常见的python内建的特殊方法<code>__xxx__</code>：</strong></p>
<ul>
<li>基础方法:<ul>
<li><code>__new__(self[,arg1,…])</code>,<code>__init__(self[,arg1,…])</code>,<code>__del__(self)</code></li>
<li><code>__str__(self)</code> 可打印的字符串输出；内建 <code>str()</code> 及 <code>print()</code> 函数</li>
<li><code>__repr__(self)</code> 运行时的字符串输出；内建 <code>repr()</code> 函数及 <code>&#39; &#39;</code> 操作符</li>
<li><code>__len__(self)</code> 长度；内建 <code>len()</code></li>
<li><code>__nonezero__(self)</code> 为实例定义 False 值；内建 <code>bool()</code> 函数</li>
<li><code>__call__(self,*args)</code> 用于可调用的实例；可以用来替代闭包的实现</li>
</ul>
</li>
<li>值比较:<ul>
<li><code>__cmp__(self,obj)</code> 对象比较；内建 <code>cmp()</code></li>
<li><code>__lt__(self,obj)</code>,<code>__le__(self,obj)</code>  小于 &amp; 小于等于；内建<code>&lt;</code> &amp; <code>&lt;=</code></li>
<li><code>__gt__(self,obj)</code>,<code>__ge__(self,obj)</code>  大于 &amp; 大于等于；内建 <code>&gt;</code> &amp; <code>&gt;=</code></li>
<li><code>__eq__(self,obj)</code>,<code>__ne__(self,obj)</code>  等于 &amp; 不等于；内建 <code>=</code> &amp; <code>!=</code></li>
</ul>
</li>
<li>类的属性:<ul>
<li><code>__getattr/setattr/delattr__(self,attr)</code> 获取/设置/删除属性；注：<code>__getattr__</code>内建 <code>getattr()</code>，仅在属性没有找到时调用</li>
<li><code>__getattribute__(self,attr)</code> 获取属性；内建 <code>getattr()</code>；总是被调用</li>
<li><code>__get/set/delete__(self,attr)</code> （描述符）获取／设置／删除属性    </li>
</ul>
</li>
<li>数值类型：<ul>
<li><code>__complex__(self, com)</code> 内建 <code>complex()</code></li>
<li><code>__int__(self)</code>  内建 <code>int()</code></li>
<li><code>__float__(self)</code> 内建 <code>float()</code></li>
<li><code>__index__(self)</code> 在有必要时，压缩可选的数值类型为整型（比如用于切片索引时等）</li>
<li><code>__neg/pos/abs/invert__(self)</code> 一元负/一元正/绝对值/按位求反(内建 ~ 操作符)</li>
<li><code>__add/sub/mul/dev/mod/pow__(self,obj)</code> : <code>+,-,*,/,%,**</code></li>
<li><code>__lshift/rshift/and/or/xor__(self,obj)</code> : <code>&lt;&lt;,&gt;&gt;,&amp;,|,^</code></li>
</ul>
</li>
<li>序列类型:<ul>
<li><code>__len__(self)</code> 序列中的项目数</li>
<li><code>__getitem__(self, ind)</code>,<code>__setitem__(self, ind,val)</code>,<code>__delitem__(self, ind)</code> 获取／设置／删除元素</li>
<li><code>__getslice__(self, ind1,ind2)</code>,<code>__setslice__(self, i1, i2,val)</code>,<code>__delslice__(self, ind1,ind2)</code> 获取／设置/删除切片元素</li>
<li><code>__contains__(self, val)</code> 含有成员；内建 in 关键字</li>
<li><code>__*add__(self,obj)</code> 串联；<code>+</code> 操作符</li>
<li><code>__*mul__(self,obj)</code> 重复；<code>*</code>操作符</li>
<li><code>__iter__(self)</code> 生成迭代器；内建 <code>iter()</code> 函数</li>
</ul>
</li>
<li>映射类型：<ul>
<li><code>__len__(self)</code> 类中的项目数</li>
<li><code>__hash__(self)</code> 散列（hash）函数值</li>
<li><code>__getitem__(self,key)</code>,<code>__setitem__(self,key,val)</code>,<code>__delitem__(self,key)</code> 获取/设置/删除某个值</li>
<li><code>__missing__(self,key)</code>        给定键若不存在，则返回一个默认值</li>
</ul>
</li>
</ul>
<p><strong>Sample1:使用<code>__call__</code>实现：为可调用对象</strong></p>
<ul>
<li>使用了<code>__call__</code>后，对实例进行直接调用就好比对一个函数进行调用一样，<br>除了用<code>instance.method(...)</code>调用实例方法，可以直接对实例进行调用<code>instance(...)</code></li>
<li>能被调用的对象就是一个<code>Callable</code>对象通过<code>callable()</code>函数判断一个对象是否是“可调用”对象</li>
</ul>
<pre><code class="lang-python">class Cat:
    def __init__(self,name):
        self.name=&#39;Cat&#39;

    def __call__(self):
        print(&quot;I am %s.&quot; % self.name)

    def eat(self):
        print(&#39;%s is eating...&#39; % self.name)

&gt;&gt;&gt; c=Cat(&#39;Tom&#39;)
&gt;&gt;&gt; c()                 # 可直接对实例进行调用
I am Cat.
&gt;&gt;&gt; callable(c)
True
&gt;&gt;&gt; c.eat()
Tom is eating...
</code></pre>
<p><strong>Sample2:使用<code>__getattr__</code>实现：动态返回一个属性值</strong></p>
<p><code>__getattr__</code> 特性：</p>
<ul>
<li>获取属性，只有在没有找到属性的情况下，才调用</li>
<li>实现若不写返回值则表示返回None，不会再抛出AttributeError</li>
</ul>
<pre><code class="lang-python">class Cat:
    def __init__(self,name):
        self.name=&#39;Cat&#39;
    def __getattr__(self,attr):
        if attr==&#39;age&#39;:
            return 0
        elif attr==&#39;color&#39;:
            return lambda:&#39;Red&#39;
        #raise AttributeError(&#39;This object has no attribute \&#39;%s\&#39;&#39; % attr)
        return &#39;N/A&#39;

&gt;&gt;&gt; c=Cat(&#39;Tom&#39;)
&gt;&gt;&gt; c.age
0
&gt;&gt;&gt; c.color()
&#39;Red&#39;
&gt;&gt;&gt; c.sex
&#39;N/A&#39;
&gt;&gt;&gt; c.country
&#39;N/A&#39;
</code></pre>
<p><strong>应用：链式调用组建path</strong></p>
<pre><code class="lang-python">class PathChain:
    def __init__(self,path=&#39;&#39;):
        self.path=path

    def __getattr__(self,attr):
        return PathChain(&#39;%s/%s&#39; % (self.path,attr))

    def __str__(self):
        return self.path
    __repr__=__str__

    def __call__(self,path):
        return PathChain(&#39;%s/%s&#39; % (self.path,path))

&gt;&gt;&gt; PathChain().users.roles
/users/roles
&gt;&gt;&gt; PathChain().users(&#39;Tom&#39;).roles
/users/Tom/roles
</code></pre>
<p><strong>Sample3:使用<code>__iter__</code>&amp;<code>__next__</code>实现迭代</strong></p>
<p><code>__iter__</code>返回一个迭代对象，for循环不断调用该迭代对象的<code>__next__</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环</p>
<pre><code class="lang-python"># f(n)=f(n-2)+f(n-1),f(0)=0,f(1)=1
# a=f(n-2),b=f(n-1)
# n: 0,1,2,3,4,5,6,7 ,8
# v: 0,1,1,2,3,5,8,13,21
class Fib:
    def __init__(self,n):    # n&gt;=1
        self.a,self.b=0,1
        self.i,self.n=0,n

    def __iter__(self):
        return self

    def __next__(self):
        if self.i==0:
            self.i+=1
            return self.a
        self.a,self.b=self.b,self.a+self.b
        self.i+=1
        if self.i &gt; self.n:
            raise StopIteration()
        return self.a

&gt;&gt;&gt; for i in Fib(9):
...     print(i) 
0
1
1
2
3
5
8
13
21

&gt;&gt;&gt; list(Fib(9))
[0, 1, 1, 2, 3, 5, 8, 13, 21]

&gt;&gt;&gt; f=Fib(5)
&gt;&gt;&gt; next(f)
0
&gt;&gt;&gt; next(f)
1
&gt;&gt;&gt; next(f)
1
&gt;&gt;&gt; next(f)
2
&gt;&gt;&gt; next(f)
3
&gt;&gt;&gt; next(f)
StopIteration                             Traceback (most recent call last)
&lt;ipython-input-34-aff1dd02a623&gt; in &lt;module&gt;
----&gt; 1 next(f)
...
</code></pre>
<p><strong>Sample4:使用<code>__getitem__</code>实现按照下标／切片取出元素</strong></p>
<pre><code class="lang-python">class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 0, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            a, b = 0, 1
            start,stop = n.start or 0, n.stop
            result = []
            for x in range(stop):
                if x&gt;=start:
                    result.append(a)
                a, b = b, a + b
            return result

&gt;&gt;&gt; f=Fib()
&gt;&gt;&gt; f[0]
&gt;&gt;&gt; f[8]
21
&gt;&gt;&gt; f[0:9]                             # [start,end)
[0, 1, 1, 2, 3, 5, 8, 13,21]
&gt;&gt;&gt; f[3:8]
[2, 3, 5, 8, 13]
</code></pre>
<h2 id="header-46">模块与包</h2>
<h3 id="header-47">导入</h3>
<ol>
<li><p><code>import ... [as ...]</code></p>
<pre><code class="lang-python"> import math,time
 math.sqrt(2)
 time.sleep(3)

 import math as mt,time as tt
 mt.sqrt(2)
 tt.sleep(3)
</code></pre>
</li>
<li><p><code>from ... import ...</code></p>
<pre><code class="lang-python"> from math import sqrt,pow
 sqrt(2)
 pow(2,3)

 from math import *     # 注：无法使用as重命名
 sqrt(2)
 pow(2,3)

 from math import sqrt as st,pow as pw
 st(2)
 pw(2,3)
</code></pre>
</li>
<li><p>模块定位顺序(存储在<code>system</code>模块的<code>sys.path</code>变量中):</p>
<pre><code class="lang-python"> &gt;&gt;&gt; import sys
 &gt;&gt;&gt; sys.path
 [&#39;&#39;, &#39;/anaconda3/lib/python37.zip&#39;, &#39;/anaconda3/lib/python3.7&#39;, &#39;/anaconda3/lib/python3.7/lib-dynload&#39;, &#39;/anaconda3/lib/python3.7/site-packages&#39;, &#39;/anaconda3/lib/python3.7/site-packages/aeosa&#39;]
</code></pre>
<ul>
<li>从上面列出的目录里依次查找要导入的模块文件</li>
<li>搜索顺序：<ul>
<li>当前目录（上面<code>&#39;&#39;</code> 即表示当前目录）</li>
<li>shell变量<code>PYTHONPATH</code>下的每个目录</li>
<li>python安装路径</li>
</ul>
</li>
<li>添加搜索目录:<ul>
<li>法一：直接修改<code>sys.path</code>,动态添加，运行结束后就失效. eg: <code>sys.path.insert(0, xxx)</code> 可以确保先搜索xxx这个路径</li>
<li>法二：设置环境变量<code>PYTHONPATH</code></li>
</ul>
</li>
</ul>
</li>
<li><p>一个程序进程下，模块被导入后，<code>import...</code>/<code>from...import...</code> 并不能重新导入模块，重新导入需先<code>import importlib</code>，<code>importlib.reload(moduleName)</code></p>
<pre><code class="lang-bash"> # 1. initial:
 $ mkdir First
 $ vi First/hello.py
 def say():
     print(&#39;say hello&#39;)

 # 2. run:
 $ python3
 &gt;&gt;&gt; import First.hello
 &gt;&gt;&gt; First.hello.say()
 say hello

 # 3. update module function:
 $ vi First/hello.py
 def say():
     print(&#39;say hello again&#39;)

 # 4. back to previous process,re-import and test:
 &gt;&gt;&gt; import First.hello
 &gt;&gt;&gt; First.hello.say() 
 say hello                     # no change!

 # 5. use importlib reload the module
 &gt;&gt;&gt; import importlib
 &gt;&gt;&gt; importlib.reload(First.hello)
 &gt;&gt;&gt; First.hello.say()
 say hello again             # changed!
</code></pre>
</li>
</ol>
<h3 id="header-48">自定义库</h3>
<ol>
<li><p>库：包／模块 =&gt; 根目录：文件夹/文件 (命名空间隔离的执行者)</p>
<ul>
<li>包：文件夹，树状结构，可放入多个层级包／模块</li>
<li>模块：文件，一个python文件本身就可以作为一个Module导入，此时模块名＝文件名    </li>
</ul>
</li>
<li><p>包初始化文件：<code>__init__.py</code> =&gt; 代表可执行包（导入包时会执行它对应的<code>__init__.py</code>文件）</p>
<ul>
<li>暴露当前包对外的API，以控制这个包的导入行为</li>
<li>同module一样，导入时，此文件里的语句就会被执行: <ul>
<li>module =&gt; module.py(like: module/<strong>init</strong>.py)</li>
<li>package =&gt; package/<strong>init</strong>.py</li>
</ul>
</li>
<li>无此文件时，无法配置包的特殊变量<code>__all__</code>，则<code>import *</code>时无内容开放</li>
<li>注：只能控制此文件中的变量 &amp; 当前目录下的模块或包的开放（不包括子目录下内容的控制）</li>
</ul>
</li>
<li><p>特殊变量：</p>
<ul>
<li><code>__name__</code><ul>
<li>直接运行此<code>.py</code>时，此属性值=<code>&#39;__main__&#39;</code></li>
<li>以模块形式被导入时，此属性值=<code>&#39;文件名&#39;</code></li>
<li>可根据此变量的结果判断是直接执行的python脚本还是被引入执行的，从而能够有选择性的执行测试代码</li>
</ul>
</li>
<li>私有化变量：<code>_xxx</code>,<code>__xxx</code><ul>
<li>只对<code>import *</code>方式的导入有制约效果，对<code>import xxx</code>的导入无效</li>
</ul>
</li>
<li><code>__all__</code><ul>
<li>可设置<code>__all__=[&#39;..&#39;,&#39;..&#39;,...]</code>，列出可对外公开的内容（即外面可导入使用的内容）<ul>
<li>在<code>package/__init__.py</code>中，控制此package（一级）目录下开放的模块 &amp; 子包 &amp; package包本身init文件中定义的变量，即控制<code>package/*</code>内容的开放</li>
<li>在<code>module.py</code>中，控制此module下开放的变量（此module.py可看做是module的<code>__init__.py</code>),即控制<code>module/*</code>内容的开放</li>
</ul>
</li>
<li>只对<code>import *</code>方式的导入有用，对<code>import xxx</code>的导入无效</li>
<li>配置的优先级高于私有化变量，即配置后，私有化变量<code>_xxx</code>,<code>__xxx</code>的制约效果无效了，只受<code>__all__</code>约束</li>
</ul>
</li>
</ul>
</li>
<li><p>导入: </p>
<ul>
<li>导入时使用<code>.</code>表路径层级,eg:<code>p1/p2/hello.py</code><ul>
<li>导入包：<code>import p1</code>,<code>import p1.p2</code></li>
<li>导入模块： <code>import p1.p2.hello</code>,<code>from p1.p2 import hello</code></li>
<li>导入模块中的变量：<code>from p1.p2.hello import v1,v2,...</code></li>
<li>导入包下一级开放内容：<code>from p1 import *</code></li>
<li>导入模块中开放内容：<code>from p1.p2.hello import *</code></li>
<li>可混合导入包和模块</li>
<li>注：不可以<code>from p1 import p2.hello</code></li>
</ul>
</li>
<li>导入时就会依次执行对应的<code>.py</code>文件<ul>
<li><code>import path</code>: <ul>
<li>step: 沿路径搜索，并沿途执行初始化(即执行<code>path</code>经过的包<code>__init__.py</code>&amp; 模块<code>module.py</code>)，导入所有变量</li>
<li>止于此<code>path</code>，会执行<code>path/__init__.py</code> or <code>path.py</code>,<code>__all__</code>配置不会起作用（因为并未导入<code>path/*.py</code>）</li>
</ul>
</li>
<li><code>from path import *</code>: <ul>
<li>step1: <code>from path</code> =&gt; 沿路径搜索，并沿途执行初始化（即执行<code>path</code>经过的包<code>__init__.py</code> &amp; 模块<code>module.py</code>），但不会导入这些变量</li>
<li>step2: <code>import *</code> =&gt; 执行<code>path/*</code>下直属py文件并导入变量<ul>
<li><code>path/__init__.py</code>先执行，会根据其中定义的<code>__all__</code>控制可导入变量；</li>
<li>若path代表的是module,则<code>module.py</code>即相当于它的<code>__init__.py</code></li>
</ul>
</li>
<li>止于<code>path/*</code>，会执行<code>path/*.py</code>,根据<code>path/__init__.py</code>中配置的<code>__all__</code>导入变量</li>
</ul>
</li>
</ul>
</li>
<li>总结: <ul>
<li><code>import</code>部分导入变量，<code>from</code>部分不导入变量;</li>
<li><code>path</code>：代表到此文件（包或模块）,<code>*</code>：代表<code>path/*.py</code>（受<code>path/__init__.py</code>中<code>__all__</code>限制）</li>
</ul>
</li>
<li>eg: <code>import path</code><ul>
<li>导入包：<code>import First.sub</code> =&gt; import first initial vars + sub initial vars</li>
<li>导入包：<code>from First import sub</code> =&gt; import sub initial vars</li>
<li>导入模块：<code>from First import hello</code> =&gt; import hello initial vars</li>
<li>导入模块：<code>import First.hello</code> =&gt; import first initial vars + hello initial vars</li>
<li>导入变量：<code>from First.hello import A,_B,__C,Cat</code> =&gt; import A,_B,__C,Cat</li>
</ul>
</li>
<li>eg: <code>from path import *</code>    <ul>
<li>导入包：<code>from First import *</code> =&gt; depends on the <code>__all__</code> in first initial py: <code>[&#39;hello&#39;,&#39;MCount&#39;,&#39;sub&#39;]</code> =&gt;  first opened initial vars: <code>MCount</code> + hello initial vars: <code>hello.*</code> + sub initial vars <code>sub.*</code></li>
<li>导入包：<code>from First.sub import *</code> =&gt; depends on the <code>__all__</code> in first initial py: <code>[&#39;aa&#39;]</code> =&gt; aa initial vars</li>
<li>导入变量：<code>from First.hello import *</code> =&gt; depends on the <code>__all__</code> in <code>hello.py</code>: <code>[&#39;A&#39;,&#39;__C&#39;,&#39;Cat&#39;]</code> =&gt; hello opened initial vars:<code>A</code>,<code>__C</code>,<code>Cat</code></li>
<li>注：无法使用<code>from First import sub.aa</code>，<code>from First import sub.*</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>Sample:</strong></p>
<pre><code class="lang-bash">First
├── __init__.py             # __all__=[&#39;hello&#39;,&#39;MCount&#39;,&#39;sub&#39;]
│                              # MCount=2,MNum=3
│
├── hello.py                 # __all__=[&#39;A&#39;,&#39;__C&#39;,&#39;Cat&#39;]
│                              # A=[1,2,3],_B=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],__C=(&#39;Hello&#39;,&#39;Tom&#39;)
│                              # def say():..., class Cat: ...
├── world.py
│ 
├── sub
│   ├── __init__.py         # __all__=[&#39;aa&#39;],sub_var=1
│   ├── aa.py                 # colorA=&#39;Red&#39;
│   └── bb.py                 # colorB=&#39;Green&#39;
</code></pre>
<ol>
<li><p>单独测试某个模块的功能（使用<code>__name__</code>区分状态）</p>
<pre><code class="lang-bash"> $ cat First/hello.py
 print(&#39;hello.py init&#39;)
 __all__=[&#39;A&#39;,&#39;__C&#39;,&#39;Cat&#39;]

 A=[1,2,3]
 _B=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
 __C=(&#39;Hello&#39;,&#39;Tom&#39;)

 def say():
     print(&#39;say hello again&#39;)

 class Cat:
     def eat(self):
         print(&#39;Cat is eating...&#39;)

 if __name__ == &#39;__main__&#39;:
     # do test:
     say()
     c=Cat()
     c.eat()

 # 单独测试验证hello.py功能：
 $ python3 First/hello.py
 hello.py init
 A=[1, 2, 3],_B=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],__C=(&#39;Hello&#39;, &#39;Tom&#39;)
 say hello again
 Cat is eating...
</code></pre>
</li>
<li><p>使用<code>import xxx</code> =&gt; 不受<code>xxx</code>的<code>__all__</code>控制</p>
<ul>
<li>xxx最终为包 <code>import First</code>,<code>import First.sub</code><pre><code class="lang-python">  &gt;&gt;&gt; import First             # 会执行First的__init__.py，导入其中所有变量
  First package init.
  &gt;&gt;&gt; dir()
  [&#39;First&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]
  &gt;&gt;&gt; dir(First)
  [&#39;MCount&#39;, &#39;MNum&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;]
</code></pre>
<pre><code class="lang-python">  &gt;&gt;&gt; import First.sub         # 会执行First的__init__.py &amp; sub的__init__.py，导入其中所有变量
  First package init.
  sub package init.
  &gt;&gt;&gt; dir()
  [&#39;First&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]
  &gt;&gt;&gt; dir(First)
  [&#39;MCount&#39;, &#39;MNum&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;, &#39;sub&#39;]
  &gt;&gt;&gt; dir(First.sub)
  [&#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;, &#39;sub_var&#39;]
</code></pre>
</li>
<li>xxx最终为模块 <code>import First.hello</code>,<code>from First import hello</code><pre><code class="lang-python">  &gt;&gt;&gt; import First.hello         # 会执行 First的__init__.py &amp; hello.py，导入其中所有变量
  First package init.
  hello.py init
  &gt;&gt;&gt; dir()
  [&#39;First&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]
  &gt;&gt;&gt; dir(First)
  [&#39;MCount&#39;, &#39;MNum&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;, &#39;hello&#39;]
  &gt;&gt;&gt; dir(First.hello)
  [&#39;A&#39;, &#39;Cat&#39;, &#39;_B&#39;, &#39;__C&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;say&#39;]
</code></pre>
<pre><code class="lang-python">  &gt;&gt;&gt; from First import hello # 执行hello.py，导入其中所有变量
  First package init.
  hello.py init
  &gt;&gt;&gt; dir()
  [&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;hello&#39;]
  &gt;&gt;&gt; dir(hello)
  [&#39;A&#39;, &#39;Cat&#39;, &#39;_B&#39;, &#39;__C&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;say&#39;]
</code></pre>
</li>
<li>xxx最终为变量 <code>from First.hello import A,_B,__C,say,Cat</code><pre><code class="lang-python">  &gt;&gt;&gt; from First.hello import A,_B,__C,say,Cat
  First package init.
  hello.py init
  &gt;&gt;&gt; dir()
  [&#39;A&#39;, &#39;Cat&#39;, &#39;_B&#39;, &#39;__C&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;say&#39;]
</code></pre>
</li>
</ul>
</li>
<li><p>使用<code>from xxx import *</code> =&gt; 受<code>xxx/__init__.py</code>中<code>__all__</code>的控制</p>
<ul>
<li>xxx为包 <code>from First import *</code>，<code>from First.sub import *</code><pre><code class="lang-python">  &gt;&gt;&gt; from First import *         # = from First import hello,sub
  First package init.
  hello.py init
  sub package init.
  &gt;&gt;&gt; dir()                         # 受First/__init__.py 中`__all__`控制
  [&#39;MCount&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;hello&#39;, &#39;sub&#39;]
  &gt;&gt;&gt; dir(hello)                     # 不受hello.py 中`__all__`控制
  [&#39;A&#39;, &#39;Cat&#39;, &#39;_B&#39;, &#39;__C&#39;, &#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;say&#39;]
  &gt;&gt;&gt; dir(sub)                # 不受sub/__init__.py 中`__all__`控制
  [&#39;__all__&#39;, &#39;__builtins__&#39;, &#39;__cached__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__path__&#39;, &#39;__spec__&#39;, &#39;sub_var&#39;]
</code></pre>
<pre><code class="lang-python">  &gt;&gt;&gt; from First.sub import *     
  First package init.
  sub package init.
  sub/aa.py init.
  &gt;&gt;&gt; dir()                         # 受sub/__init__.py 中`__all__`控制
  [&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;aa&#39;]
</code></pre>
</li>
<li>xxx为模块 <code>from First.hello import *</code><pre><code class="lang-python">  &gt;&gt;&gt; from First.hello import *     # = from First.hello import A,Cat,__C
  First package init.
  hello.py init
  &gt;&gt;&gt; dir()                         # 受hello.py 中`__all__`控制
  [&#39;A&#39;, &#39;Cat&#39;, &#39;__C&#39;, &#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;]
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="header-49">发布/安装包</h3>
<ul>
<li>发布：<ul>
<li>编辑<code>setup.py</code>文件</li>
<li>构建模块 <code>python setup.py build</code></li>
<li>生成发布压缩包 <code>python setup.py sdist</code></li>
</ul>
</li>
<li>安装：<ul>
<li>解压获得的压缩包</li>
<li>进入文件夹，执行<code>python setup.py install</code> (可加参数指定安装路径：<code>--prefix=安装路径</code>)</li>
</ul>
</li>
<li>使用：<code>from ... import ...</code>，<code>import package.module</code> 导入</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-bash">Second
├── setup.py
├── subA
│   ├── __init__.py
│   ├── aa.py
│   └── bb.py
└── subB
    ├── __init__.py
    ├── cc.py
    └── dd.py
</code></pre>
<p>发布：</p>
<pre><code class="lang-bash"># 1. setup.py:
$ cd Second
$ vi setup.py
from distutils.core import setup
setup(name=&quot;SecondPkg&quot;, 
    version=&quot;1.0&quot;, 
    description=&quot;Second module&quot;, 
    author=&quot;dongGe&quot;, 
    py_modules=[&#39;subA.aa&#39;, &#39;subA.bb&#39;, &#39;subB.cc&#39;,&#39;subB.dd&#39;]) 
    # py_modules 需指明所需包含的py文件

# 2. build: 构建 (发布的包下一定要有`__init__.py`文件，不然会build失败)
$ python setup.py build
running build
running build_py
copying subA/__init__.py -&gt; build/lib/subA
copying subB/__init__.py -&gt; build/lib/subB

# 3. 查看（实际就是copy了一份到`build/lib`下）
$ tree
.
├── build
│   └── lib
│       ├── subA
│       │   ├── __init__.py
│       │   ├── aa.py
│       │   └── bb.py
│       └── subB
│           ├── __init__.py
│           ├── cc.py
│           └── dd.py
├── setup.py
├── subA
│   ├── __init__.py
│   ├── aa.py
│   └── bb.py
└── subB
    ├── __init__.py
    ├── cc.py
    └── dd.py

# 4. sdist: 生成发布压缩包 (产生`MANIFEST`文件，`dist/SecondPkg-1.0.tar.gz`压缩包)
$ python setup.py sdist
$ tree
.
├── MANIFEST
├── build
│   └── lib
│       ├── subA
│       │   ├── __init__.py
│       │   ├── aa.py
│       │   └── bb.py
│       └── subB
│           ├── __init__.py
│           ├── cc.py
│           └── dd.py
├── dist
│   └── SecondPkg-1.0.tar.gz
├── setup.py
├── subA
│   ├── __init__.py
│   ├── aa.py
│   └── bb.py
└── subB
    ├── __init__.py
    ├── cc.py
    └── dd.py
</code></pre>
<p>安装：</p>
<pre><code class="lang-bash"># 1. 解压
$ tar -xvf SecondPkg-1.0.tar.gz

# 2. 进入文件夹
$ cd SecondPkg-1.0
$ tree
.
├── PKG-INFO
├── setup.py
├── subA
│   ├── __init__.py
│   ├── aa.py
│   └── bb.py
└── subB
    ├── __init__.py
    ├── cc.py
    └── dd.py

# 3. 安装
$ python setup.py install
...
creating /anaconda3/lib/python3.7/site-packages/subA
...
creating /anaconda3/lib/python3.7/site-packages/subB
...
running install_egg_info
Writing /anaconda3/lib/python3.7/site-packages/SecondPkg-1.0-py3.7.egg-info

# 4. 查看安装的包
$ pip list | grep Second
SecondPkg                          1.0

# 5. 使用
$ cd ~/space
$ python3

# 导入包：
&gt;&gt;&gt; from subB import *             # 注意：不要使用 `import subA,subB` -- 不会导入包下的任何模块
subB init.
This subB/cc.py
This subB/dd.py
&gt;&gt;&gt; dir()
[&#39;__annotations__&#39;, &#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__loader__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__spec__&#39;, &#39;cc&#39;, &#39;dd&#39;]

# 导入模块：
&gt;&gt;&gt; from subA.aa import *  # 或 `from subA import aa` 或 `import subA.aa`
subA init.
This subA/aa.py
</code></pre>
<h3 id="header-50">常用标准库</h3>
<p>Python的一个组成部分，随着Python解释器，一起安装在电脑中的</p>
<table class="table">
<thead>
<tr>
<th style="text-align:left">标准库</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">builtins</td>
<td style="text-align:left">内建函数默认加载</td>
</tr>
<tr>
<td style="text-align:left">os</td>
<td style="text-align:left">操作系统接口</td>
</tr>
<tr>
<td style="text-align:left">sys</td>
<td style="text-align:left">Python自身的运行环境</td>
</tr>
<tr>
<td style="text-align:left">functools</td>
<td style="text-align:left">常用的工具</td>
</tr>
<tr>
<td style="text-align:left">json</td>
<td style="text-align:left">编码和解码JSON对象</td>
</tr>
<tr>
<td style="text-align:left">logging</td>
<td style="text-align:left">记录日志，调试</td>
</tr>
<tr>
<td style="text-align:left">multiprocessing</td>
<td style="text-align:left">多进程</td>
</tr>
<tr>
<td style="text-align:left">threading</td>
<td style="text-align:left">多线程</td>
</tr>
<tr>
<td style="text-align:left">copy</td>
<td style="text-align:left">拷贝</td>
</tr>
<tr>
<td style="text-align:left">time</td>
<td style="text-align:left">时间</td>
</tr>
<tr>
<td style="text-align:left">datetime</td>
<td style="text-align:left">日期和时间</td>
</tr>
<tr>
<td style="text-align:left">calendar</td>
<td style="text-align:left">日历</td>
</tr>
<tr>
<td style="text-align:left">hashlib</td>
<td style="text-align:left">加密算法</td>
</tr>
<tr>
<td style="text-align:left">random</td>
<td style="text-align:left">生成随机数</td>
</tr>
<tr>
<td style="text-align:left">re</td>
<td style="text-align:left">字符串正则匹配</td>
</tr>
<tr>
<td style="text-align:left">socket</td>
<td style="text-align:left">标准的 BSD Sockets API</td>
</tr>
<tr>
<td style="text-align:left">shutil</td>
<td style="text-align:left">文件和目录管理</td>
</tr>
<tr>
<td style="text-align:left">glob</td>
<td style="text-align:left">基于文件通配符搜索</td>
</tr>
<tr>
<td style="text-align:left">collections</td>
<td style="text-align:left">一个集合模块，提供了许多有用的集合类</td>
</tr>
</tbody>
</table>
<p><strong>Sample:datetime</strong></p>
<pre><code class="lang-python">&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; datetime.now()                         # 1. 获取当前datetime
datetime.datetime(2019, 3, 17, 11, 58, 22, 874984)
&gt;&gt;&gt; type(datetime.now())
&lt;class &#39;datetime.datetime&#39;&gt;

&gt;&gt;&gt; dt=datetime(2018, 5, 19, 13, 10)     # 2. 指定某个日期和时间的datetime
&gt;&gt;&gt; print(dt)
2018-05-19 13:10:00

&gt;&gt;&gt; ts=dt.timestamp()                     # 3.1: datetime -&gt; timestamp
&gt;&gt;&gt; ts
1526706600.0
&gt;&gt;&gt; datetime.fromtimestamp(ts)             # 3.2: timestamp -&gt; datetime 本地时间
datetime.datetime(2018, 5, 19, 13, 10)
&gt;&gt;&gt; datetime.utcfromtimestamp(ts)         # 3.2: timestamp -&gt; datetime UTC时间
datetime.datetime(2018, 5, 19, 5, 10)

&gt;&gt;&gt; dt.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)     # 4.1: datetime -&gt; str
&#39;2018-05-19 13:10:00&#39;
&gt;&gt;&gt; str(dt)
&#39;2018-05-19 13:10:00&#39;
&gt;&gt;&gt; datetime.strptime(&#39;2018-05-19 13:10:00&#39;,&#39;%Y-%m-%d %H:%M:%S&#39;)     # 4.2: str -&gt; datetime
datetime.datetime(2018, 5, 19, 13, 10)

&gt;&gt;&gt; from datetime import timedelta         # 5. datetime +/-
&gt;&gt;&gt; dt+timedelta(hours=10)
datetime.datetime(2018, 5, 19, 23, 10)
&gt;&gt;&gt; dt-timedelta(days=2, hours=12)
datetime.datetime(2018, 5, 17, 1, 10)

&gt;&gt;&gt; from datetime import timezone                     # 6. 时区转换
&gt;&gt;&gt; dt_utc=dt.replace(tzinfo=timezone.utc)            # 6.1 强制设置为utc时区，作为基准时间
&gt;&gt;&gt; dt_utc
datetime.datetime(2018, 5, 19, 13, 10, tzinfo=datetime.timezone.utc)
&gt;&gt;&gt; print(dt_utc)
2018-05-19 13:10:00+00:00
&gt;&gt;&gt; dt_utc.astimezone(timezone(timedelta(hours=8))) # 转换北京时区(UTC+8)
datetime.datetime(2018, 5, 19, 21, 10, tzinfo=datetime.timezone(datetime.timedelta(seconds=28800)))
&gt;&gt;&gt; dt_utc.astimezone(timezone(timedelta(hours=9))) # 转换东京时区(UTC+9)
datetime.datetime(2018, 5, 19, 22, 10, tzinfo=datetime.timezone(datetime.timedelta(seconds=32400)))

&gt;&gt;&gt; dt_bj=dt_utc.astimezone(timezone(timedelta(hours=8)))
&gt;&gt;&gt; dt_bj.astimezone(timezone(timedelta(hours=9)))    # 北京时间转换为东京时间(UTC+9)
datetime.datetime(2018, 5, 19, 22, 10, tzinfo=datetime.timezone(datetime.timedelta(seconds=32400)))
</code></pre>
<ul>
<li><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，默认视为本地时区时间</li>
<li>时区转换: 确定一个<code>datetime</code>的时区（可强制设置时区，作为基准时间），利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区</li>
<li>存储<code>datetime</code>，最佳方法是将其转换为<code>timestamp</code>再存储，因为<code>timestamp</code>的值与时区完全无关</li>
</ul>
<p><strong>Sample:Collections</strong></p>
<ul>
<li>namedtuple : tuple子类，可用属性而不是索引来引用tuple的元素</li>
<li>deque : 双向列表（list是线性存储，数据量大时，插入和删除效率低），注：不是list子类</li>
<li>defaultdict : dict子类，key不存在时，不会报错而是返回一个默认值</li>
<li>OrderedDict : dict子类，Key会按照插入的顺序排列 （应用：可用来实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key）</li>
<li>ChainMap : 把一组dict串起来并组成一个逻辑上的dict，查找时按顺序在内部的dict中依次查找（应用：可用来实现参数的优先级查找），注：不是dict子类</li>
<li>Counter: dict子类，可实现一个简单的计数器</li>
</ul>
<pre><code class="lang-python"># 1. namedtuple
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])
&gt;&gt;&gt; p = Point(1, 2)
&gt;&gt;&gt; p
Point(x=1, y=2)
&gt;&gt;&gt; p.x,p.y                         # 可用属性访问
(1, 2)
&gt;&gt;&gt; isinstance(p, Point),isinstance(p, tuple)
(True, True)

# 2. deque
&gt;&gt;&gt; from collections import deque
&gt;&gt;&gt; q = deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
&gt;&gt;&gt; q.append(&#39;x&#39;)                     # append(),pop()
&gt;&gt;&gt; q.appendleft(&#39;y&#39;)                 # appendleft(),popleft()
&gt;&gt;&gt; q
deque([&#39;y&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;x&#39;])
&gt;&gt;&gt; isinstance(q,list)
False

# 3. defaultdict
&gt;&gt;&gt; from collections import defaultdict
&gt;&gt;&gt; d = defaultdict(lambda: &#39;N/A&#39;)
&gt;&gt;&gt; d[&#39;a&#39;] = 123
&gt;&gt;&gt; d[&#39;a&#39;]
123
&gt;&gt;&gt; d[&#39;b&#39;]                         # 访问存在key,返回设置的默认值，不会报错
&#39;N/A&#39;
&gt;&gt;&gt; isinstance(d,dict)
True

# 4. ChainMap
&gt;&gt;&gt; from collections import ChainMap
&gt;&gt;&gt; m=ChainMap({&#39;a&#39;:1,&#39;b&#39;:2},{&#39;b&#39;:3,&#39;c&#39;:4})
&gt;&gt;&gt; m[&#39;a&#39;],m[&#39;b&#39;],m[&#39;c&#39;]
(1, 2, 4)
&gt;&gt;&gt; isinstance(m,dict)
False

# 5. Counter
&gt;&gt;&gt; from collections import Counter
&gt;&gt;&gt; c = Counter()
&gt;&gt;&gt; for i in &#39;programming&#39;:     # 统计字符出现的个数，效果同：c={},c[i]=c.get(i,0)+1
...  c[i] += 1
...
&gt;&gt;&gt; c
Counter({&#39;r&#39;: 2, &#39;g&#39;: 2, &#39;m&#39;: 2, &#39;p&#39;: 1, &#39;o&#39;: 1, &#39;a&#39;: 1, &#39;i&#39;: 1, &#39;n&#39;: 1})
&gt;&gt;&gt; isinstance(c,dict)
True
</code></pre>
<p><strong>Sample:hashlib</strong></p>
<pre><code class="lang-python">&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; m=hashlib.md5()
&gt;&gt;&gt; m.update(b&#39;Hello&#39;)
&gt;&gt;&gt; m.hexdigest()
&#39;8b1a9953c4611296a827abf8c47804d7&#39;
</code></pre>
<h3 id="header-51">常用扩展库</h3>
<table class="table">
<thead>
<tr>
<th style="text-align:left">扩展库</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">requests</td>
<td style="text-align:left">使用的是urllib3，继承了urllib2的所有特性</td>
</tr>
<tr>
<td style="text-align:left">urllib</td>
<td style="text-align:left">基于http的高层库</td>
</tr>
<tr>
<td style="text-align:left">scrapy</td>
<td style="text-align:left">爬虫</td>
</tr>
<tr>
<td style="text-align:left">beautifulsoup4</td>
<td style="text-align:left">HTML/XML的解析器</td>
</tr>
<tr>
<td style="text-align:left">celery</td>
<td style="text-align:left">分布式任务调度模块</td>
</tr>
<tr>
<td style="text-align:left">redis</td>
<td style="text-align:left">缓存</td>
</tr>
<tr>
<td style="text-align:left">Pillow(PIL)</td>
<td style="text-align:left">图像处理</td>
</tr>
<tr>
<td style="text-align:left">xlsxwriter</td>
<td style="text-align:left">仅写excle功能,支持xlsx</td>
</tr>
<tr>
<td style="text-align:left">xlwt</td>
<td style="text-align:left">仅写excle功能,支持xls ,2013或更早版office</td>
</tr>
<tr>
<td style="text-align:left">xlrd</td>
<td style="text-align:left">仅读excle功能</td>
</tr>
<tr>
<td style="text-align:left">elasticsearch</td>
<td style="text-align:left">全文搜索引擎</td>
</tr>
<tr>
<td style="text-align:left">pymysql</td>
<td style="text-align:left">数据库连接库</td>
</tr>
<tr>
<td style="text-align:left">mongoengine/pymongo</td>
<td style="text-align:left">mongodbpython接口</td>
</tr>
<tr>
<td style="text-align:left">matplotlib</td>
<td style="text-align:left">画图</td>
</tr>
<tr>
<td style="text-align:left">numpy/scipy</td>
<td style="text-align:left">科学计算</td>
</tr>
<tr>
<td style="text-align:left">django/tornado/flask</td>
<td style="text-align:left">web框架</td>
</tr>
<tr>
<td style="text-align:left">xmltodict</td>
<td style="text-align:left">xml转dict</td>
</tr>
<tr>
<td style="text-align:left">SimpleHTTPServer</td>
<td style="text-align:left">简单地HTTP Server,不使用Web框架</td>
</tr>
<tr>
<td style="text-align:left">gevent</td>
<td style="text-align:left">基于协程的Python网络库</td>
</tr>
<tr>
<td style="text-align:left">fabric</td>
<td style="text-align:left">系统管理</td>
</tr>
<tr>
<td style="text-align:left">pandas</td>
<td style="text-align:left">数据处理库</td>
</tr>
<tr>
<td style="text-align:left">scikit-learn</td>
<td style="text-align:left">机器学习库</td>
</tr>
</tbody>
</table>
<p><strong>Sample:SimpleHTTPServer</strong></p>
<ol>
<li>运行一个静态（目录）服务器<pre><code class="lang-bash"> $ cd Second
 $ python -m http.server 8000
 Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
</code></pre>
</li>
<li>visit <code>http://localhost:8000</code> 就可以看到列出了当前目录的页面，可方便的查看文件<pre><code class="lang-bash"> $ curl http://localhost:8000
 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
 &lt;html&gt;
 &lt;head&gt;
 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
 &lt;title&gt;Directory listing for /&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;h1&gt;Directory listing for /&lt;/h1&gt;
 &lt;hr&gt;
 &lt;ul&gt;
 &lt;li&gt;&lt;a href=&quot;build/&quot;&gt;build/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;dist/&quot;&gt;dist/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;MANIFEST&quot;&gt;MANIFEST&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;setup.py&quot;&gt;setup.py&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;subA/&quot;&gt;subA/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href=&quot;subB/&quot;&gt;subB/&lt;/a&gt;&lt;/li&gt;
 &lt;/ul&gt;
 &lt;hr&gt;
 &lt;/body&gt;
 &lt;/html&gt;
</code></pre>
</li>
</ol>
<h2 id="header-52">文件IO</h2>
<h3 id="header-53">读写文件</h3>
<ul>
<li>打开文件：<code>f=open(filename,mode=&#39;r&#39;,encoding=None)</code></li>
<li>关闭文件：<code>f.close()</code></li>
<li>用<code>with</code>语句包裹打开文件，不管是否异常，自动关闭文件，更保险（或使用<code>try...finally</code>）</li>
<li>读：<ul>
<li><code>content=f.read(128)</code> =&gt; str</li>
<li><code>content=f.readline()</code> =&gt; str</li>
<li><code>content=f.readlines()</code> =&gt; list</li>
</ul>
</li>
<li>写：<ul>
<li><code>f.write(&#39;...&#39;)</code> =&gt; int: length</li>
<li><code>f.writelines(...)</code></li>
<li><code>f.flush()</code> 缓冲区内容刷新到文件中</li>
</ul>
</li>
<li>查看当前位置：<code>position = f.tell()</code></li>
<li>定位到某个位置：<code>f.seek(offset, from)</code>  <ul>
<li>offset: 偏移量</li>
<li>from: 0 文件开头/ 1 当前位置 / 2 文件末尾</li>
<li>eg: <code>f.seek(2, 1)</code>: 从头开始，偏移2个字节; <code>f.seek(-3,2)</code>: 离文件末尾，3字节处</li>
</ul>
</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python"># 写
f = open(&#39;test.txt&#39;, &#39;w&#39;)      # 追加可用a
f.write(&#39;hello world, i am here!&#39;)
f.close()

# 读
f = open(&#39;test.txt&#39;, &#39;r&#39;)
content = f.read(128) # content = f.readline(),contentlst = f.readlines()
position = f.tell()
f.close()

# 使用with语句，会自动关闭
with open(&#39;test.txt&#39;, &#39;w&#39;) as f
    f.write(&#39;Hello world&#39;)
</code></pre>
<h3 id="header-54">操作文件／目录</h3>
<ul>
<li><code>import os</code>,<code>import shutil</code>(可以看做是os模块的补充，有更多方便的操作命令)</li>
<li>系统相关：<ul>
<li><code>os.name</code> 查看操作系统类型（posix：Linux、Unix或Mac OS X；nt：Windows）</li>
<li><code>os.uname()</code> 获取详细的系统信息（Windows上不提供）</li>
<li><code>os.environ</code> 获取环境变量（dict,os.environ.get(‘PATH’)）</li>
</ul>
</li>
<li>路径相关：<code>os.path</code><ul>
<li>查看绝对路径 <code>os.path.abspath(path)</code></li>
<li>合成路径 <code>os.path.join(p1,p2,...)</code></li>
<li>拆分路径 <code>os.path.split(path)</code></li>
<li>文件扩展名 <code>os.path.splitext(path)</code></li>
<li>是否是文件 <code>os.path.isfile(x)</code></li>
<li>是否是文件夹 <code>os.path.isdir(x)</code><br>－ 操作文件/文件夹：</li>
<li>获取当前路径 <code>os.getcwd()</code></li>
<li>改变当前路径 <code>os.chdir(path)</code></li>
<li>列出文件／文件夹(<code>ls</code>) <code>os.listdir(path)</code></li>
<li>创建文件夹 <code>os.mkdir(dir)</code></li>
<li>删除空文件夹 <code>os.rmdir(dir)</code></li>
<li>重命名／移动文件／文件夹（<code>mv</code>） <code>os.rename(src,dist)</code></li>
<li>删除文件 <code>os.remove(file)</code></li>
<li>拷贝文件：<code>shutil.copyfile(src,dist)</code></li>
</ul>
</li>
</ul>
<h2 id="header-55">多任务</h2>
<ol>
<li><p>同步(Sync) &amp; 异步(Async)：消息通知机制</p>
<ul>
<li>同步：主动等</li>
<li>异步：被动听</li>
</ul>
</li>
<li><p>阻塞(Blocking) &amp; 非阻塞(UnBlocking)：等待消息通知时的调用者状态</p>
<ul>
<li>阻塞：等待 （one thread do one task)</li>
<li>非阻塞：继续做其他事 (one thread do many tasks,高吞吐量)</li>
</ul>
</li>
<li><p>并发(Concurrent) &amp; 并行 (Parallel)：多任务处理能力</p>
<ul>
<li>并发：交替运行</li>
<li>并行：同时运行</li>
</ul>
</li>
<li><p>进程(Process) &amp; 线程(Thread)：多任务处理手段</p>
<ul>
<li>进程：独立地址空间，进程间独立运行（eg: 多核CPU，并行运行）</li>
<li>线程：进程内，多线程共享同一段地址空间，但有自己独立的堆栈和局部变量（eg: 单核CPU多线程，并发运行）</li>
</ul>
</li>
<li><p>组合（举例 Task：烧水 &amp; 看电视）</p>
<ul>
<li>阻塞 &amp; 同步<ul>
<li>烧水 -&gt; 等水开（主动看）-&gt; 看电视 ：效率低</li>
</ul>
</li>
<li>阻塞 &amp; 异步  <ul>
<li>烧水 -&gt; 水壶响（被动听）-&gt; 看电视：效率低</li>
</ul>
</li>
<li>非阻塞 &amp; 同步<ul>
<li>烧水 &amp; 看电视 &amp; 时不时看下水（主动看）: 来回切换，效率低</li>
</ul>
</li>
<li>非阻塞 &amp; 异步<ul>
<li>烧水 &amp; 看电视 &amp; 水壶响了再去关（被动听）：减少切换，效率高</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="header-56">进程 Process</h3>
<ol>
<li><p><code>os.fork()</code>: 只在Unix/Linux/Mac上运行，windows不可以</p>
<pre><code class="lang-python"> $ cat fork-demo.py
 import os,time

 num=1
 ret = os.fork()
 if ret==0:      # sub-process do:
     num=num-1   # should be 0
     print(&quot;sub-process:%s,pid:%s,ppid:%s num:%s&quot; % (ret,os.getpid(),os.getppid(),num))
 else:           # main-process do:
     num=num+1   # should be 2
     print(&quot;main-process:%s,pid:%s,ppid:%s num:%s&quot; % (ret,os.getpid(),os.getppid(),num))

 time.sleep(3)

 print(&#39;End&#39;)

 $ python fork-demo.py
 main-process:30929,pid:30928,ppid:6855 num:2
 sub-process:0,pid:30929,ppid:30928 num:0
 End
 End

 $ ps
    PID TTY           TIME CMD
  6855 ttys001    0:00.03 -bash
 30928 ttys001    0:00.02 python fork-demo.py
 30929 ttys001    0:00.00 python fork-demo.py
 28023 ttys002    0:00.02 -bash
</code></pre>
<ul>
<li>分出一个子进程，后面的代码会分别在原有进程和新创建进程运行</li>
<li>返回0: 代表当前是新创建的子进程</li>
<li>返回非0: 代表当前是原本的父进程（返回的数字＝子进程pid）</li>
<li>即子进程永远返回0，父进程返回子进程的ID</li>
<li>每个进程中所有数据（包括全局变量）都各有拥有一份，互不影响</li>
<li>父子进程互补影响，父进程结束不会导致子进程结束</li>
<li>1次fork-&gt;2个进程，2次fork－&gt;4个进程，…</li>
</ul>
</li>
<li><p><code>multiprocessing.Process</code>: 通用</p>
<pre><code class="lang-python"> $ cat process-demo.py
 from multiprocessing import Process
 import os,time,random

 # 法一
 def task(name):
     print(&quot;子进程(%s) task %s start&quot; % (os.getpid(),name))
     time.sleep(random.random()*2) 
     print(&quot;子进程(%s) task %s end&quot; % (os.getpid(),name))

 # 法二
 class MyProcess(Process):
     def __init__(self,name):
         Process.__init__(self)
         self.name=name

     def run(self):
         print(&quot;子进程(%s) task %s start&quot; % (os.getpid(),self.name))
         time.sleep(random.random()*2) 
         print(&quot;子进程(%s) task %s end&quot; % (os.getpid(),self.name))

 if __name__==&#39;__main__&#39;:
     print(&#39;父进程(%s) 开始&#39; % os.getpid())

     # p = Process(target=task, args=(&#39;test&#39;,))   # 创建子进程，法一：创建一个Process实例
     p = MyProcess(&#39;test&#39;)                       # 创建子进程，法二：创建一个自定义的继承自Process类的实例

     p.start()   # 启动子进程
     p.join()    # 父进程阻塞等待子进程结束后再继续往下运行，非必需
     print(&#39;子进程(%s) 结束&#39; % p.name)
     print(&#39;父进程(%s) 结束&#39; % os.getpid())

 $ python process-demo.py
 父进程(39487) 开始
 子进程(39488) task test start
 子进程(39488) task test end
 子进程(test) 结束
 父进程(39487) 结束
</code></pre>
<ul>
<li>创建<ul>
<li>法一：创建一个Process实例</li>
<li>法二：自定义一个类，继承<code>Process</code>类，重写<code>run</code>方法</li>
</ul>
</li>
<li>启动：<code>p.start()</code> 内部调用<code>run</code>方法</li>
<li>等待结束：<code>p.join([timeout])</code></li>
<li>终止：<code>p.terminate()</code></li>
<li>判断是否还在执行：<code>is_alive()</code></li>
<li>常用属性：<ul>
<li><code>name</code>：当前进程实例别名，默认为Process-N，N为从1开始递增的整数</li>
<li><code>pid</code>：当前进程实例的PID值</li>
</ul>
</li>
<li>注：<ul>
<li>父进程结束不影响子进程</li>
<li>子进程无法访问父进程创建的全局变量</li>
<li>变量可通过参数传递</li>
</ul>
</li>
</ul>
</li>
<li><p><code>multiprocessing.Pool</code>: 进程池</p>
<pre><code class="lang-python"> from multiprocessing import Pool
 import os,time,random

 def task(name):
     print(&quot;子进程(%s): task %s =&gt; start&quot; % (os.getpid(),name))
     t=random.random()*2
     time.sleep(t) 
     print(&quot;子进程(%s): task %s =&gt; end(sleep:%.2f)&quot; % (os.getpid(),name,t))
     return os.getpid(),name

 def task_callback(arg):         # 父进程中执行，以元组方式获取task return值
     print(&quot;父进程(%s): 获取子进程(%s) task %s =&gt; callback&quot; % (os.getpid(),arg[0],arg[1]))

 if __name__==&#39;__main__&#39;:
     print(&#39;父进程(%s): =&gt; 开始&#39; % os.getpid())

     p=Pool(3)
     for i in range(0,5):
         # p.apply(task,(i,))      # 阻塞方式发配任务(等一个任务完成后，再发布下一个)
         p.apply_async(task,(i,),callback=task_callback)  # 非阻塞方式发配任务（一次性发布3个，等空出进程后，再发布下一）

     p.close()   # 关闭进程池，是以不再接收新的请求
     p.join()    # 父进程阻塞等待所有子进程执行完成，必须放在close语句之后（不加join的话可能子进程还未完成就整个退出了）
     print(&#39;所有子进程结束&#39;)
     print(&#39;父进程(%s): =&gt; 结束&#39; % os.getpid())

 # 阻塞方式结果：
 $ python pool-demo.py
 父进程(44350): =&gt; 开始
 子进程(44351): task 0 =&gt; start
 子进程(44351): task 0 =&gt; end(sleep:1.30)
 子进程(44352): task 1 =&gt; start
 子进程(44352): task 1 =&gt; end(sleep:0.27)
 子进程(44353): task 2 =&gt; start
 子进程(44353): task 2 =&gt; end(sleep:0.53)
 子进程(44351): task 3 =&gt; start
 子进程(44351): task 3 =&gt; end(sleep:1.68)
 子进程(44352): task 4 =&gt; start
 子进程(44352): task 4 =&gt; end(sleep:0.53)
 所有子进程结束
 父进程(44350): =&gt; 结束

 # 非阻塞方式结果：
 $ python pool-demo.py
 父进程(44306): =&gt; 开始
 子进程(44307): task 0 =&gt; start
 子进程(44308): task 1 =&gt; start
 子进程(44309): task 2 =&gt; start
 子进程(44309): task 2 =&gt; end(sleep:0.89)
 子进程(44309): task 3 =&gt; start
 父进程(44306): 获取子进程(44309) task 2 =&gt; callback
 子进程(44307): task 0 =&gt; end(sleep:1.14)
 子进程(44307): task 4 =&gt; start
 父进程(44306): 获取子进程(44307) task 0 =&gt; callback
 子进程(44308): task 1 =&gt; end(sleep:1.50)
 父进程(44306): 获取子进程(44308) task 1 =&gt; callback
 子进程(44309): task 3 =&gt; end(sleep:0.92)
 父进程(44306): 获取子进程(44309) task 3 =&gt; callback
 子进程(44307): task 4 =&gt; end(sleep:1.36)
 父进程(44306): 获取子进程(44307) task 4 =&gt; callback
 所有子进程结束
 父进程(44306): =&gt; 结束
</code></pre>
<ul>
<li>初始化Pool时，可以指定一个最大进程数</li>
<li>若进程数达到指定的最大值，直到池中有进程任务结束，下一个任务请求才会发布给空闲进程执行</li>
<li><code>apply(func, args=(), kwds={})</code> 阻塞方式发布任务给一个进程，必须等待上一个进程任务结束才能执行下一个</li>
<li><code>apply_async(func, args=(), kwds={}, callback=None, error_callback=None)</code> 非阻塞方式，有空闲进程即可发布执行 </li>
<li><code>close()</code> 关闭进程池，使其不再接受新的任务</li>
<li><code>terminate()</code> 不管任务是否完成，立即终止</li>
<li><code>join()</code> 主进程阻塞等待子进程们结束，必须在<code>close</code>或<code>terminate</code>之后使用</li>
<li>注：<ul>
<li>父进程结束会影响子进程</li>
<li>变量可通过参数传递</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Queue</code>: 消息列队</p>
<pre><code class="lang-python"> $ cat process-queue.py
 from multiprocessing import Process, Queue
 from multiprocessing import Manager,Pool
 import os, time, random

 def produce_task(q):
     while True:
         if not q.full():
             t=random.random()
             q.put(t)
             print(&#39;produce:%.2f&#39; % t)
             time.sleep(t)
         else:
             print(&#39;stop produce!&#39;)
             break

 def consume_task(q):
     while True:
         if not q.empty():
             t=q.get()
             print(&#39;consume:%.2f&#39; % t)
             time.sleep(t)
         else:
             print(&#39;stop consume!&#39;)
             break

 def process_test():
     q=Queue(5)
     p_produce=Process(target=produce_task,args=(q,))
     p_consume=Process(target=consume_task,args=(q,))
     p_produce.start()
     p_consume.start()
     p_produce.join()
     p_consume.join()
     print(&quot;Done!&quot;)

 def pool_test():
     q=Manager().Queue(5)
     p=Pool(2)
     p.apply_async(produce_task,(q,))
     p.apply_async(consume_task,(q,))
     p.close()
     p.join()
     print(&quot;Done!&quot;)

 if __name__==&#39;__main__&#39;:
     # process_test()
     pool_test()

 $ python process-queue.py
 produce:0.04
 consume:0.04
 produce:0.99
 consume:0.99
 stop consume!
 produce:0.07
 produce:0.13
 produce:0.96
 produce:0.86
 produce:0.27
 stop produce!
 Done!
</code></pre>
<ul>
<li>进程间通信，可使用<code>multiprocessing.Queue()</code></li>
<li>进程池进程通讯，可使用<code>multiprocessing.Manager().Queue()</code></li>
<li><code>get(block=True,timeout=None)</code> 从队列中弹出一个消息（无消息则阻塞或抛出Queue.Empty异常）</li>
<li><code>get_nowait()</code> = <code>get(False)</code></li>
<li><code>put(item,block=True,timeout=None)</code> 将一个消息写入队列（队列满了则阻塞或抛出Queue.Full异常）</li>
<li><code>put_nowait(item)</code> = <code>put(item,False)</code></li>
<li><code>qsize()</code> 当前队列包含的消息数量 =&gt; 效果不好，可能会报NotImplementedError</li>
<li><code>empty()</code> 判断当前队列是否为空</li>
<li><code>full()</code> 判断当前队列是否满了</li>
</ul>
</li>
</ol>
<h3 id="header-57">线程 Thread</h3>
<p>threading模块</p>
<ul>
<li>Python的thread模块较底层，threading模块对thread做了一些包装，更方便</li>
<li>Python解释器（CPython）在解析多线程时，会使用<code>GIL</code>全局排他锁（<code>Global Interpreter Lock</code>），不管几核CPU，同一时刻只有一个线程能使用到CPU，从而导致多线程无法利用多核，解决方法有<ul>
<li>用多进程<code>multiprocess</code>代替多线程</li>
<li>使用其他解析器（GIL只是CPython的产物）</li>
<li>使用c语言实现多线程（利用<code>ctypes</code>模块直接调用任意的C动态库的导出函数）</li>
</ul>
</li>
<li>使用：<ul>
<li>创建线程：<ul>
<li>法一：创建一个Thread实例 <code>Thread(group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None)</code></li>
<li>法二：自定义一个类，继承<code>Thread</code>类，重写<code>run</code>方法</li>
</ul>
</li>
<li><code>start()</code> 启动</li>
<li><code>join()</code> 主线程阻塞等待子线程结束后再继续，非必需</li>
<li><code>is_alive()</code> 判断线程是否活着</li>
<li><code>name</code> 线程名字，默认<code>Thread-1</code>,<code>Thread-2</code>,…</li>
</ul>
</li>
<li>线程同步<ul>
<li>多个线程有序协同工作</li>
<li>场景：<ul>
<li>多个线程共同争夺修改某个共享数据，如全局变量，一个进程内的所有线程共享全局变量（各线程可修改，线程非安全）</li>
<li>生产-消费者，速度不匹配，需要一个缓冲协同</li>
</ul>
</li>
<li>实现方式：<ul>
<li>互斥锁 Mutex<ul>
<li>每次只有一个线程可以上锁，其他需要获得这个锁的线程变为<code>blocked</code>状态</li>
<li>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行<code>running</code>状态</li>
<li>锁：相当于一块独占空间，一次只能进一个人（线程）</li>
<li>创建锁: <code>mutex=threading.Lock()</code></li>
<li>锁住：<code>mutex.acquire(blocking=True, timeout=-1)</code> =&gt; 锁状态：<code>locked</code>,锁住的那个线程：<code>running</code>,其他需要这个锁的线程：<code>blocked</code></li>
<li>开锁：<code>mutex.release()</code> =&gt; 锁状态:<code>unlocked</code>,需要这个锁的线程开始争夺这个锁，获这个锁的线程状态从<code>blocked</code>变成<code>runing</code></li>
<li>死锁：不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁 =&gt; 需尽量避免，如添加超时时间等</li>
</ul>
</li>
<li>队列 Queue<ul>
<li><code>from queue import Queue</code></li>
<li><code>q=Queue(maxsize＝0)</code></li>
<li><code>.get(block=True,timeout=None)</code>,<code>.put(item,block=True,timeout=None)</code></li>
<li><code>.qsize()</code>,<code>.full()</code>,<code>.empty()</code>,<code>.join()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>注：<ul>
<li>主进程，一个主线程运行</li>
<li>主线程结束，不会导致子线程结束</li>
<li>线程间传递数据：<ul>
<li>全局变量</li>
<li>传参</li>
</ul>
</li>
<li>线程自己的数据：<ul>
<li>局部变量</li>
<li>ThreadLocal<ul>
<li>定义一个全局变量 <code>l=threading.local()</code></li>
<li>每个Thread对它的读写互不影响 <code>l.xxx</code>,<code>l.xxx=xxx</code></li>
<li>类似一个dict</li>
<li>虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰</li>
<li>解决了参数在一个线程中各个函数之间互相传递的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Sample1:Thread</strong></p>
<pre><code class="lang-python">from threading import Thread
import threading
import os,time,random

def task(name):
    print(&quot;%s do task %s start&quot; % (threading.current_thread().name,name))
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print(&quot;%s do task %s end (%.2f)&quot; % (threading.current_thread().name,name,end-start))


class MyThread(Thread):
    def __init__(self,taskName):
        Thread.__init__(self)
        self.taskName=taskName

    def run(self):
        print(&quot;%s do task %s start&quot; % (self.name,self.taskName)) # name属性中保存的是当前线程的名字
        start = time.time()
        time.sleep(random.random() * 3)
        end = time.time()
        print(&quot;%s do task %s end (%.2f)&quot; % (self.name,self.taskName,end-start))


def thread_inst_test():
    t=Thread(target=task,args=(&#39;test&#39;,))
    t.start()

def thread_class_test():
    t=MyThread(&#39;test&#39;)
    t.start()


if __name__==&#39;__main__&#39;:
    print(&quot;%s thread start&quot; % threading.current_thread().name)

    # thread_inst_test()

    thread_class_test()

    print(&quot;%s thread end&quot; % threading.current_thread().name)
</code></pre>
<pre><code class="lang-bash">$ python thread-demo.py
MainThread thread start
Thread-1 do task test start
MainThread thread end
Thread-1 do task test end (0.47)
</code></pre>
<p><strong>Sample2: Multiple tasks</strong></p>
<pre><code class="lang-python"># test1: 异步,多线程交错打印
# result sample:
# Thread-1 print 1
# Thread-2 print 1
# Thread-1 print 2
# Thread-1 print 3
# Thread-1 done!
# Thread-2 print 2
# Thread-2 print 3
# Thread-2 done!
def test_multi_tasks_async():
    def async_task():
        for i in range(1,4):
            print(&quot;%s print %d &quot; % (threading.current_thread().name,i))
            time.sleep(random.random())
        print(&quot;%s done!&quot; % threading.current_thread().name)

    t1=Thread(target=async_task)
    t2=Thread(target=async_task)
    t1.start()
    t2.start()

# test2: 同步,多线程顺序打印
# result sample:
# Thread-1 print 1
# Thread-1 print 2
# Thread-1 print 3
# Thread-1 done!
# Thread-2 print 1
# Thread-2 print 2
# Thread-2 print 3
# Thread-2 done!
def test_multi_tasks_sync():
    mutex=threading.Lock()

    def sync_task():
        if mutex.acquire():
            for i in range(1,4):
                print(&quot;%s print %d &quot; % (threading.current_thread().name,i))
                time.sleep(random.random())
            print(&quot;%s done!&quot; % threading.current_thread().name)
            mutex.release()

    t1=Thread(target=sync_task)
    t2=Thread(target=sync_task)
    t1.start()
    t2.start()
</code></pre>
<p><strong>Sample3:Mutex</strong></p>
<pre><code class="lang-python"># test: 操作共享资源，不加锁，结果不正确,shoud be 0
# result sample:
# Done Thread-1 do add,num = 208671
# Done Thread-2 do sub,num = -102681
def test_multi_tasks_global_val():
    num=0
    def add_task():
        global num
        for i in range(0,1000000):
            num+=1
        print(&quot;Done %s do add,num = %d &quot; % (threading.current_thread().name,num))

    def sub_task():
        global num
        for i in range(0,1000000):
            num-=1
        print(&quot;Done %s do sub,num = %d &quot; % (threading.current_thread().name,num))

    t1=Thread(target=add_task)
    t2=Thread(target=sub_task)
    t1.start()
    t2.start()

# test: 操作共享资源，加锁，得正确结果,be 0
# result sample:
# Done Thread-2 do sub,num = -36334
# Done Thread-1 do add,num = 0
def test_multi_tasks_global_val_mutex():
    lock=threading.Lock()
    num=0
    def add_task():
        nonlocal num
        for i in range(0,1000000):
            lock.acquire()
            num+=1
            lock.release()
        print(&quot;Done %s do add,num = %d &quot; % (threading.current_thread().name,num))

    def sub_task():
        nonlocal num
        for i in range(0,1000000):
            lock.acquire()
            num-=1
            lock.release()
        print(&quot;Done %s do sub,num = %d &quot; % (threading.current_thread().name,num))

    t1=Thread(target=add_task)
    t2=Thread(target=sub_task)
    t1.start()
    t2.start()
</code></pre>
<p><strong>Sample4:Queue</strong></p>
<pre><code class="lang-python">Queue
# result sample:
# Consumer [0] Begin
# Consumer [0] handle item: 5.77
# Consumer [1] Begin
# Consumer [2] Begin
# Waiting for all threads done...
# Consumer [2] handle item: 4.51
# Consumer [1] handle item: 3.87
# Consumer [0] handle item: 1.61
# Consumer [1] handle item: 6.42
# Consumer [2] handle item: 0.17
# Consumer [1] handle item: 9.36
# Consumer [0] handle item: 4.88
# Consumer [1] handle item: 8.63
# Consumer [1] handle item: 0.27
# Consumer [2] Done
# Consumer [0] Done
# Consumer [1] Done
# All threads done.

def test_thread_queue():
    import queue

    def queue_consumer(index,q):
        print(&quot;Consumer [%s] Begin&quot; % index)
        while not q.empty():
            item = q.get()
            if not item:
                time.sleep(1)
                continue
            do_task(index,item)
        print(&#39;Consumer [%s] Done&#39; % index)

    def do_task(index,item):
        print(&quot;Consumer [%s] handle item: %s&quot; % (index,item))
        time.sleep(random.random())

    q=queue.Queue()
    [q.put(&quot;%.2f&quot; % (random.random()*10)) for i in range(10)]

    t_list=[]
    for i in range(3):
        t=threading.Thread(target=queue_consumer,args=(i,q,))
        t.start()
        t_list.append(t)

    print(&#39;Waiting for all threads done...&#39;)
    for t in t_list:
        t.join()
    print(&#39;All threads done.&#39;)
</code></pre>
<p><strong>Sample5:ThreadLocal</strong></p>
<pre><code class="lang-python">ThreadLocal
# result sample:
# Done Thread-1 task: step=0
# Done Thread-5 task: step=40
# Done Thread-2 task: step=10
# Done Thread-3 task: step=20
# Done Thread-4 task: step=30

def test_thread_dict():
    thread_dict = {}

    def task(step):
        thread_dict[threading.current_thread()]=step
        do_task()

    def do_task():
        currentThread=threading.current_thread()
        step=thread_dict[currentThread]
        time.sleep(random.random())
        print(&quot;Done %s task: step=%s&quot; % (currentThread.name,step))

    for i in range(5):
        t=Thread(target=task,args=(i*10,))
        t.start()


def test_thread_local():

    #thread_dict = {}
    thread_local = threading.local()

    def task(step):
        #thread_dict[threading.current_thread()]=step
        thread_local.step=step
        do_task()

    def do_task():
        currentThread=threading.current_thread()
        #step=thread_dict[currentThread]
        step=thread_local.step
        time.sleep(random.random())
        print(&quot;Done %s task: step=%s&quot; % (currentThread.name,step))

    for i in range(5):
        t=Thread(target=task,args=(i*10,))
        t.start()
</code></pre>
<h3 id="header-58">协程 Coroutine</h3>
<blockquote>
<p>Async programming allows you to write concurrent code that runs in a single thread. The first advantage compared to multiple threads is that you decide where the scheduler will switch from one task to another, which means that sharing data between tasks it’s safer and easier.<br>With asynchronous programming, you allow your code to handle other tasks while waiting for these other resources to respond.</p>
</blockquote>
<ul>
<li>async IO，被动通知，单线程多任务（非阻塞），执行效率高</li>
<li>与多线程对比优势：<ul>
<li>没有线程切换的开销</li>
<li>共享资源无需加锁也不会发生冲突（判断状态即可）</li>
</ul>
</li>
</ul>
<p>使用Python标准库：<code>asyncio</code> （Python 3.4引入）<br>编程模型: 一个消息循环，从<code>asyncio</code>模块中获取一个<code>EventLoop</code>的引用，把需要执行的协程扔到<code>EventLoop</code>中执行</p>
<ol>
<li><p><code>Coroutine</code> 协同任务</p>
<pre><code class="lang-python"> # method1: use `@asyncio.coroutine`
 @asyncio.coroutine
 def my_task(args):
     print(&#39;start&#39;)
     yield from asyncio.sleep(3)  # 用`yield from`调用另一个`coroutine`实现异步操作
     print(&#39;end&#39;)

 # method2: use `async`
 async def my_task(args):
     print(&#39;start&#39;)
     await asyncio.sleep(3)     # 用`await`调用另一个`coroutine`实现异步操作
     print(&#39;end&#39;)

 # return a coroutine object
 my_coroutine = my_task(args)
</code></pre>
<ul>
<li>一个用<code>@asyncio.coroutine</code>或<code>async</code>标注的function</li>
<li><code>xxx(args)</code>,不会执行方法体中的语句，只是返回一个coroutine object</li>
<li><code>async</code>&amp;<code>await</code>是Python 3.5引入的语法糖，<code>async</code>代替<code>@asyncio.coroutine</code>,<code>await</code>代替<code>yield from</code>（Note: <code>await</code> keyword can only be used inside an <code>async def function</code>）</li>
</ul>
</li>
<li><p><code>EventLoop</code> 事件循环（事件池）</p>
<pre><code class="lang-python"> # 1. create loop： 从`asyncio`模块中获取一个`EventLoop`的引用
 loop = asyncio.new_event_loop()

 # 2. add coroutine to the loop,return a future object
 future = loop.create_task(my_coroutine)

 # 3. execute all coroutine added to the loop concurrently
 # method1:
 loop.run_until_complete(my_coroutine)
 # method2:
 loop.run_until_complete(future)

 loop.close()
</code></pre>
<ul>
<li>组织协调执行加入的协同任务</li>
<li>execute our asyncronous code and decide how to switch between async functions</li>
</ul>
</li>
<li><p>Running Tasks Concurrently(一个事件循环中执行多个task , 并发执行)</p>
<ul>
<li><code>asyncio.wait(fs, *, loop=None, timeout=None, return_when=&#39;ALL_COMPLETED&#39;)</code><ul>
<li>等待任务完成，支持在完成第一个任务后或在指定的超时之后停止等待</li>
<li>return: two sets of Future: <code>(done, pending)</code><ul>
<li><code>done</code> : 已完成的协程Task集合 <code>{asyncio.Task,asyncio.Task,...}</code></li>
<li><code>pending</code> : 超时未完成的协程Task集合</li>
<li><code>asyncio.Task</code> : extends Future, could use <code>.result()</code> get task return value</li>
</ul>
</li>
<li>usage:<ul>
<li><code>done, pending = await asyncio.wait(coros_or_futures)</code> －－ in async func</li>
<li><code>done, pending = loop.run_until_complete(async.wait(coros_or_futures))</code> －－ in normal func</li>
</ul>
</li>
</ul>
</li>
<li><code>asyncio.gather</code><ul>
<li>等待并按给定的顺序返回完成的任务结果</li>
<li>return：已完成的协程Task的结果值列表 <code>[taskReturnValue1,taskReturnValue2,...]</code></li>
<li>usage:<ul>
<li><code>results=await asyncio.gather(*coros_or_futures)</code></li>
<li><code>results=loop.run_until_complete(async.gather(*coros_or_futures))</code></li>
<li>还可对任务进行高级别分组<pre><code class="lang-python">  group1 = asyncio.gather(*[task1,task2])
  group2 = asyncio.gather(*[task3,task4])
  all_groups = asyncio.gather(group1, group2)
  results = loop.run_until_complete(all_groups)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>总结 <code>asyncio.wait</code> vs. <code>asyncio.gather</code> :<ul>
<li>都是用于获取结果的,且都不阻塞,直接返回一个生成器对象可用于 <code>yield from</code> / <code>await</code></li>
<li>都是两种用法<ul>
<li><code>results = asyncio.run_until_completed(asyncio.wait/gather)</code> 执行所有完成之后获取</li>
<li><code>results = await asyncio.wait/gather</code> 在一个协程内获取结果</li>
</ul>
</li>
<li>但返回结果不一样<ul>
<li><code>asyncio.wait</code> 返回 tuple: <code>(doneSet,pendingSet)</code></li>
<li><code>asyncio.gather</code> 返回 list: <code>[taskReturnValue1,taskReturnValue2,...]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Task</code>/<code>Future</code>(注: <code>class Task(Future)</code>): </p>
<pre><code class="lang-python"> # method1: add a coroutine to the loop and returns a `Task` which is a subtype of `Future`
 future = loop.create_task(my_coroutine)

 # method2: adds a coroutine to the default loop
 future = asyncio.ensure_future(my_coroutine)

 # could add call back for the future object
 future.add_done_callback(result_handler())
</code></pre>
<ul>
<li>works as a placeholder for the output of an asynchronous function </li>
<li>and it gives us information about the function state,</li>
<li>A future is created when we add a corutine to an event loop</li>
</ul>
</li>
<li><p>Run Result: </p>
<pre><code class="lang-python"> # method1: use the `yield from` or `await`
 result=await my_coroutine

 # method2: add it to an event loop
 future=loop.create_task(my_coroutine)
 result=future.result()
</code></pre>
<ul>
<li>Get the output of an async function from a coroutine</li>
</ul>
</li>
<li><p>Exception handling: </p>
<pre><code class="lang-python"> # method1: try catch the exception
 try:    
     future.result() # this will re-raise the exception raised during the coroutine execution
 except Exception:
     pass

 # method2: get the exception information
 future.exception()
</code></pre>
<ul>
<li>method1: <code>try...except...</code> 捕获异常</li>
<li>method2: 调用<code>future.exception()</code>异常信息</li>
<li>Note：unhandled exception raised inside a coroutine doesn’t break the program,it will be stored inside the future and get <code>Task exception was never retrieved</code> error before program exit.</li>
</ul>
</li>
</ol>
<p><strong>Sample1:<code>@asyncio.coroutine</code> &amp; <code>yield from</code> vs. <code>async</code> &amp; <code>await</code></strong></p>
<ol>
<li><p><code>@asyncio.coroutine</code> &amp; <code>yield from</code></p>
<pre><code class="lang-python"> import asyncio
 import random

 @asyncio.coroutine
 def hello(name):
     r=random.random()*3
     print(&#39;Hello %s, sleep %s&#39; % (name,r))
     yield from asyncio.sleep(r)
     print(&#39;Hello %s wake up!&#39; % name)

 if __name__ == &#39;__main__&#39;:
     loop = asyncio.get_event_loop()                 # 获取EventLoop
     #tasks = [hello(&quot;Tom&quot;), hello(&quot;Lucy&quot;)]
     t1=loop.create_task(hello(&quot;Tom&quot;))
     t2=loop.create_task(hello(&quot;Lucy&quot;))
     tasks=[t1,t2]                                   # t1,t2 is future
     loop.run_until_complete(asyncio.wait(tasks))    # 执行
     loop.close()
</code></pre>
</li>
<li><p><code>async</code> &amp; <code>await</code></p>
<pre><code class="lang-python"> import asyncio
 import random

 async def hello(name):                                # 使用`async` 代替`@asyncio.coroutine`
     r=random.random()*3
     print(&#39;Hello %s, sleep %s&#39; % (name,r))
     await asyncio.sleep(r)                            # 使用`await` 代替`yield from`
     print(&#39;Hello %s wake up!&#39; % name)

 if __name__ == &#39;__main__&#39;:
     loop = asyncio.get_event_loop()
     # tasks = [hello(&quot;Tom&quot;), hello(&quot;Lucy&quot;)]
     t1=loop.create_task(hello(&quot;Tom&quot;))
     t2=loop.create_task(hello(&quot;Lucy&quot;))
     tasks=[t1,t2]
     loop.run_until_complete(asyncio.wait(tasks))
     loop.close()
</code></pre>
</li>
</ol>
<p><strong>Sample2: <code>coroutine</code> vs. <code>future</code>, <code>asyncio.wait</code> vs. <code>asyncio.gather</code></strong></p>
<ol>
<li><p><code>coroutine</code></p>
<pre><code class="lang-python"> import asyncio
 import time,random

 async def do_async_task(index,item):
     print(&#39;[start]\t %s:\t %s&#39; % (index,item))
     start=time.time()
     await asyncio.sleep(random.random())
     end=time.time()
     result =&#39;[end]\t %s:\t %s (spent:%.2f)&#39; % (index,item,(end-start))
     return result

 if __name__==&#39;__main__&#39;:
     loop = asyncio.get_event_loop()

     task_list=[]
     for i in range(10):
         item=&quot;%.2f&quot; % (random.random()*10)
         t=do_async_task(i,item)                 # t is coroutine
         task_list.append(t)

     print(&#39;Waiting for all sub-proc done...&#39;)

     # method1: use asyncio.wait
     done,pending=loop.run_until_complete(asyncio.wait(task_list))
     print(done,pending)
     for r in done:
         print(&quot;get result:&quot;,r.result())

     # method2: use asyncio.gather
     # results=loop.run_until_complete(asyncio.gather(*task_list))
     # print(results)
     # for r in result:
     #     print(&quot;get result:&quot;,r)

     loop.close()
     print(&#39;All sub-procs done.&#39;)

     # for task in task_list:
     #     # task:
     #     # type: coroutine
     #     # sample: &lt;coroutine object do_async_task at 0x10f24c8c8&gt;
     #     print(task)
</code></pre>
</li>
<li><p><code>future</code></p>
<pre><code class="lang-python"> import asyncio
 import time,random

 async def do_async_task(index,item):
     print(&#39;[start]\t %s:\t %s&#39; % (index,item))
     start=time.time()
     await asyncio.sleep(random.random())
     end=time.time()
     result =&#39;[end]\t %s:\t %s (spent:%.2f)&#39; % (index,item,(end-start))
     return result

 def handle_result(future):
     print(&quot;callback:&quot;,future.result())

 if __name__==&#39;__main__&#39;:
     loop = asyncio.get_event_loop()
     task_list=[]
     for i in range(10):
         item=&quot;%.2f&quot; % (random.random()*10)
         t=do_async_task(i,item)                 # t is coroutine
         f=loop.create_task(t)                   # f is future
         f.add_done_callback(handle_result)
         task_list.append(f)

     print(&#39;Waiting for all sub-proc done...&#39;)

     # method1: use asyncio.wait
     done,pending=loop.run_until_complete(asyncio.wait(task_list))
     print(done,pending)
     for r in done:
         print(&quot;get result:&quot;,r.result())

     # method2: use asyncio.gather
     # results=loop.run_until_complete(asyncio.gather(*task_list))
     # print(results)
     # for r in result:
     #     print(&quot;get result:&quot;,r)

     loop.close()
     print(&#39;All sub-procs done.&#39;)

     # for task in task_list: 
     #     # task:
     #     # type: _asyncio.Task,subtype of `Future`
     #     # sample: &lt;Task finished 
     #     # coro=&lt;do_async_task() done, defined at asyncio-demo.py:5&gt; 
     #     # result=&#39;[end]\t 7:\t... (spent:0.36)&#39;&gt;
     #     print(&quot;get task result:&quot;,task.result())
</code></pre>
</li>
<li><p>Result sample:</p>
<pre><code> Waiting for all sub-proc done...
 [start]  0:  6.28
 [start]  1:  6.02
 [start]  2:  5.86
 [start]  3:  1.32
 [start]  4:  8.29
 [start]  5:  6.30
 [start]  6:  2.07
 [start]  7:  3.41
 [start]  8:  8.47
 [start]  9:  3.76
 callback: [end]  4:  8.29 (spent:0.11)
 callback: [end]  0:  6.28 (spent:0.18)
 callback: [end]  3:  1.32 (spent:0.20)
 callback: [end]  6:  2.07 (spent:0.31)
 callback: [end]  1:  6.02 (spent:0.51)
 callback: [end]  9:  3.76 (spent:0.51)
 callback: [end]  7:  3.41 (spent:0.75)
 callback: [end]  8:  8.47 (spent:0.78)
 callback: [end]  5:  6.30 (spent:0.79)
 callback: [end]  2:  5.86 (spent:1.00)
 get result: [end]    5:  6.30 (spent:0.79)
 get result: [end]    2:  5.86 (spent:1.00)
 get result: [end]    8:  8.47 (spent:0.78)
 get result: [end]    6:  2.07 (spent:0.31)
 get result: [end]    3:  1.32 (spent:0.20)
 get result: [end]    0:  6.28 (spent:0.18)
 get result: [end]    9:  3.76 (spent:0.51)
 get result: [end]    7:  3.41 (spent:0.75)
 get result: [end]    4:  8.29 (spent:0.11)
 get result: [end]    1:  6.02 (spent:0.51)
 All sub-procs done.
</code></pre></li>
</ol>
<p><strong>Sample3:queue</strong></p>
<pre><code class="lang-python">async def do_async_task(index,item):
    print(&#39;do task %s: Consumer[%s] %s&#39; % (item[0],index,item[1]))
    start=time.time()
    await asyncio.sleep(random.random())
    end=time.time()
    result =&#39;do task %s: Consumer[%s] %s (spent:%.2f)&#39; % (item[0],index,item[1],(end-start))
    return result

def handle_result(future):
    print(future.result())

async def async_queue_consumer(index,q):
    print(&quot;Consumer[%s] Begin&quot; % index)
    while not q.empty():
        item = await q.get()
        if not item:
            await asyncio.sleep(1)
            continue
        task=asyncio.create_task(do_async_task(index,item))
        task.add_done_callback(handle_result)
        await asyncio.gather(task)
    print(&#39;Consumer[%s] Done&#39; % index)

if __name__==&#39;__main__&#39;:   
    print(&quot;--- Test: asyncio queue ---&quot;)
    q=asyncio.Queue()
    [q.put_nowait((i,&quot;%.2f&quot; % (random.random()*10))) for i in range(10)]

    tasks = [async_queue_consumer(i,q) for i in range(3)]
    loop = asyncio.get_event_loop()

    print(&#39;Waiting for all sub-proc done...&#39;)
    loop.run_until_complete(asyncio.wait(tasks))
    loop.close()
    print(&#39;All sub-procs done.&#39;)
</code></pre>
<p>Result sample:</p>
<pre><code>--- Test: asyncio queue ---
Waiting for all sub-proc done...
Consumer[1] Begin
Consumer[0] Begin
Consumer[2] Begin
do task 0: Consumer[1] 5.87
do task 1: Consumer[0] 7.46
do task 2: Consumer[2] 7.20
do task 1: Consumer[0] 7.46 (spent:0.05)
do task 3: Consumer[0] 7.28
do task 2: Consumer[2] 7.20 (spent:0.61)
do task 4: Consumer[2] 7.07
do task 0: Consumer[1] 5.87 (spent:0.72)
do task 5: Consumer[1] 9.09
do task 3: Consumer[0] 7.28 (spent:0.67)
do task 6: Consumer[0] 9.65
do task 4: Consumer[2] 7.07 (spent:0.33)
do task 7: Consumer[2] 6.64
do task 6: Consumer[0] 9.65 (spent:0.89)
do task 8: Consumer[0] 3.21
do task 7: Consumer[2] 6.64 (spent:0.74)
do task 9: Consumer[2] 1.78
do task 5: Consumer[1] 9.09 (spent:0.98)
Consumer[1] Done
do task 9: Consumer[2] 1.78 (spent:0.13)
Consumer[2] Done
do task 8: Consumer[0] 3.21 (spent:0.62)
Consumer[0] Done
All sub-procs done.
</code></pre><h2 id="header-59">访问数据库</h2>
<h3 id="header-60">SQLite</h3>
<ul>
<li>SQLite是一种嵌入式数据库,它的数据库就是一个文件</li>
<li>Python就内置了SQLite3,可直接使用</li>
<li>操作：建立连接Connection，打开游标，通过Cursor执行SQL语句，获得执行结果，关闭游标，提交事物，关闭连接<ul>
<li><code>Cursor</code>对象通过<code>execute</code>方法执行SQL语句（可使用<code>?</code>占位符）</li>
<li>执行<code>insert</code>/<code>update</code>/<code>delete</code>后，可通过<code>cursor.rowcount</code>获取影响的行数</li>
<li>执行<code>select</code>后，可通过<code>cursor.featchall()</code>获取结果集列表，每个元素都是一个tuple，对应一行记录</li>
</ul>
</li>
</ul>
<p><strong>Sample:</strong></p>
<pre><code class="lang-python">import sqlite3
import os

# delte test.db
db_file = os.path.join(os.path.dirname(__file__), &#39;test.db&#39;)
if os.path.isfile(db_file):
    os.remove(db_file)


conn = sqlite3.connect(&#39;test.db&#39;)   # 建立连接（数据库文件不存在时，会创建）
cursor = conn.cursor()              # 创建并打开一个Cursor

try:
    # 执行SQL语句: create
    cursor.execute(&#39;create table user(id varchar(20) primary key, name varchar(20), score int)&#39;)

    # 执行SQL语句: insert
    cursor.execute(r&quot;insert into user values (&#39;A-001&#39;, &#39;Adam&#39;, 95)&quot;)
    print(cursor.rowcount)

    cursor.execute(r&quot;insert into user values (&#39;A-002&#39;, &#39;Bart&#39;, 62)&quot;)
    print(cursor.rowcount)

    cursor.execute(r&quot;insert into user values (&#39;A-003&#39;, &#39;Lisa&#39;, 78)&quot;)
    print(cursor.rowcount)

    # 提交事务
    conn.commit()

    # 执行SQL语句: select
    cursor.execute(&#39;select * from user where id=?&#39;, (&#39;A-001&#39;,))
    records = cursor.fetchall()
    print(records)

finally:
    cursor.close()                  # 关闭Cursor
    conn.close()                    # 关闭连接
</code></pre>
<h3 id="header-61">MySQL</h3>
<p><code>pip install mysql-connector-python</code> or <code>pip install pymysql</code></p>
<pre><code class="lang-python">#import mysql.connector as pymysql
import pymysql

conn=pymysql.connect(host=&quot;localhost&quot;,port=3316,user=&#39;root&#39;,password=&#39;123456&#39;,database=&#39;demo1&#39;)
cursor=conn.cursor()

try:
    # 执行SQL语句: drop
    cursor.execute(&#39;drop table if exists user&#39;)

    # 执行SQL语句: create
    cursor.execute(&#39;create table user(id varchar(20) primary key, name varchar(20), score int)&#39;)

    # 执行SQL语句: insert
    cursor.execute(r&quot;insert into user values (&#39;A-001&#39;, &#39;Adam&#39;, 95)&quot;)
    print(cursor.rowcount)

    cursor.execute(r&quot;insert into user values (&#39;A-002&#39;, &#39;Bart&#39;, 62)&quot;)
    print(cursor.rowcount)

    cursor.execute(r&quot;insert into user values (&#39;A-003&#39;, &#39;Lisa&#39;, 78)&quot;)
    print(cursor.rowcount)

    # 提交事务
    conn.commit()

    # 执行SQL语句: select
    # 注：这里占位符是&#39;%&#39;，不是&#39;?&#39;
    cursor.execute(&#39;select * from user where id=%s&#39;, (&#39;A-001&#39;,))
    records = cursor.fetchall()
    print(records)

finally:
    cursor.close()
    conn.close()
</code></pre>
<p>check result:</p>
<pre><code class="lang-bash">mysql&gt; use demo1
Database changed
mysql&gt; select * from user;
+-------+------+-------+
| id    | name | score |
+-------+------+-------+
| A-001 | Adam |    95 |
| A-002 | Bart |    62 |
| A-003 | Lisa |    78 |
+-------+------+-------+
3 rows in set (0.00 sec)
</code></pre>
<h3 id="header-62">Redis</h3>
<p><code>pip install redis</code></p>
<ol>
<li><p>连接Redis数据库</p>
<pre><code class="lang-python"> import redis

 # 1. 连接Redis数据库
 # method1: 直接连接
 # client=redis.Redis(host=&#39;127.0.0.1&#39;,port=6379,password=&#39;123456&#39;)

 # method2: 连接池连接(预先创建多个连接, 进行redis操作时, 直接获取已经创建的连接进行操作, 完成后,不会释放, 用于后续的其他redis操作)
 pool = redis.ConnectionPool(host=&#39;localhost&#39;, port=6379,password=&#39;123456&#39;)
 client = redis.Redis(connection_pool=pool)

 # check exist keys:
 # results=client.keys(&#39;*&#39;)
 # print(&quot;list keys * :&quot;,results)
</code></pre>
</li>
<li><p>基础数据操作: 基本redis的命令名与redis模块中的函数名一致</p>
<ul>
<li><p>String: <code>key -&gt; value</code></p>
<pre><code class="lang-python">  # 设置：
  # set(key, value, ex=None, px=None, nx=False, xx=False)
  # setnx(key, value)　            只有key不存在时设置
  # setex(key, value, time)        设置过期时间（秒）
  # mset({key:value,...})          批量设置值
  #
  # 获取：
  # get(key)
  # mget(key1,key2,...)
  # strlen(key)                   key对应值的字节长度
  #
  # 值追加内容:
  # append(key,addValue)
  def test_string():
      print(&quot;Test String:&quot;)
      result=client.set(&#39;a&#39;,1)
      print(result)                   # True

      result=client.get(&#39;a&#39;)
      print(result)                   # b&#39;1&#39;

      result=client.append(&#39;a&#39;,23)
      print(result)                   # 3

      result=client.get(&#39;a&#39;)
      print(result)                   # b&#39;123&#39;
</code></pre>
</li>
<li><p>Hash: 一个name对应一个dic字典 <code>n1 -&gt; k1:v1,k2,v2</code>,<code>n2 -&gt; kx:vx,..</code></p>
<pre><code class="lang-python">  # hset(name, key, value)
  # hget(name, key)
  # hgetall(name)
  # hmset(name, mapping)
  # hmget(name, keys, *args)
  #
  # hlen(name)
  # hkeys(name)
  # hvals(name)
  #
  # hexists(name, key)
  # hdel(name, *keys)
  # hincrby(name, key, amount=1)
  def test_hash():
      print(&quot;Test Hash:&quot;)

      result = client.hset(&#39;stu-001&#39;,&#39;name&#39;,&#39;Tom&#39;)
      print(result)                       # 1
      result = client.hmset(&#39;stu-001&#39;,{&#39;age&#39;:19,&#39;gender&#39;:&#39;male&#39;})
      print(result)                       # True
      result = client.hgetall(&#39;stu-001&#39;)
      print(result)                       # {b&#39;name&#39;: b&#39;Tom&#39;, b&#39;age&#39;: b&#39;19&#39;, b&#39;gender&#39;: b&#39;male&#39;}

      result = client.hmset(&#39;stu-002&#39;,{&#39;name&#39;:&#39;Lucy&#39;,&#39;age&#39;:16,&#39;gender&#39;:&#39;Female&#39;})
      print(result)                       # True
      result = client.hgetall(&#39;stu-002&#39;)
      print(result)                       # {b&#39;name&#39;: b&#39;Lucy&#39;, b&#39;age&#39;: b&#39;16&#39;, b&#39;gender&#39;: b&#39;Female&#39;}

      result = client.hlen(&#39;stu-001&#39;)
      print(result)                       # 3
      result = client.hkeys(&#39;stu-001&#39;)
      print(result)                       # [b&#39;name&#39;, b&#39;age&#39;, b&#39;gender&#39;]
      result = client.hvals(&#39;stu-001&#39;)
      print(result)                       # [b&#39;Tom&#39;, b&#39;19&#39;, b&#39;male&#39;]

      result = client.hincrby(&#39;stu-001&#39;,&#39;age&#39;,amount=5)
      print(result)                       # 24
      result = client.hgetall(&#39;stu-001&#39;)
      print(result)                       # {b&#39;name&#39;: b&#39;Tom&#39;, b&#39;age&#39;: b&#39;24&#39;, b&#39;gender&#39;: b&#39;male&#39;}
</code></pre>
</li>
<li><p>List: 一个name对应一个列表存储,<code>n1 -&gt; [v1,v2,...]</code>,<code>n2 -&gt; [...]</code></p>
<pre><code class="lang-python"> # lpush(name, *values),rpush(name, *values) 
 # lpushx(name, *values),rpushx(name, *values)  name存在时，才能加入
 # linsert(name, where, refvalue, value)        name对应的列表的refValue值的前或后where插入一个value
 #
 # llen(name)                        name列表长度
 # lindex(name, index)               索引获取元素
 # lrange(name, start, end)          分片获取元素
 #
 # lset(name, index, value)          索引位置重新赋值
 # lpop(name)                        移除列表的左侧第一个元素，返回值则是第一个元素
 # lrem(name, value, num=0)          删除name对应的list中的指定值
 # ltrim(name, start, end)           移除列表内没有在该索引之内的值

 def test_list():
     print(&quot;Test List:&quot;)

     result = client.lpush(&#39;group1&#39;,&#39;stu-A&#39;,&#39;stu-B&#39;,&#39;stu-C&#39;,&#39;stu-D&#39;,&#39;stu-E&#39;)
     print(result)                      # 5
     result = client.lpush(&#39;group2&#39;,&#39;child-A&#39;,&#39;child-B&#39;)
     print(result)                       # 3

     result = client.llen(&#39;group1&#39;)
     print(result)                       # 5
     result = client.lrange(&#39;group1&#39;,2,5)
     print(result)                       # [b&#39;stu-C&#39;, b&#39;stu-B&#39;, b&#39;stu-A&#39;]
</code></pre>
</li>
<li><p>Set: 不允许有重复的集合，<code>n1 -&gt; {v1,v2,...}</code>,<code>n2 -&gt; {...}</code></p>
<pre><code class="lang-python">  # sadd(name, *values)           添加元素
  # srem(name,*values)            删除元素
  # smembers(name)                列出集合所有元素
  # scard(name)                   获取元素个数
  # sismember(name, value)        测试素是否在

  # spop(name)                    从集合中随机弹出一个元素
  # smove(src, dst, value)        将一个元素从集合1移到集合2

  # sdiff/sdiffstore(keys, *args) 差集（以前一个集合为标准）
  # sinter(keys, *args)           交集
  # sunion(keys, *args)           并集

  def test_set():
      print(&quot;Test Set:&quot;)

      result = client.sadd(&#39;stdGrp1&#39;,&#39;stu-A&#39;,&#39;stu-B&#39;,&#39;stu-B&#39;,&#39;stu-C&#39;)
      print(result)                       # 3
      result = client.smembers(&#39;stdGrp1&#39;)
      print(result)                       # {b&#39;stu-B&#39;, b&#39;stu-C&#39;, b&#39;stu-A&#39;}
      result = client.scard(&#39;stdGrp1&#39;)
      print(result)                       # 3

      result = client.sadd(&#39;stdGrp2&#39;,*(&#39;stu-A&#39;,&#39;stu-C&#39;,&#39;stu-D&#39;))
      print(result)                       # 3

      result = client.sdiff(&#39;stdGrp1&#39;,&#39;stdGrp2&#39;)
      print(result)                       # {b&#39;stu-B&#39;}
      result = client.sinter(&#39;stdGrp1&#39;,&#39;stdGrp2&#39;)
      print(result)                       # {b&#39;stu-C&#39;, b&#39;stu-A&#39;}
      result = client.sunion(&#39;stdGrp1&#39;,&#39;stdGrp2&#39;)
      print(result)                       # {b&#39;stu-B&#39;, b&#39;stu-C&#39;, b&#39;stu-A&#39;, b&#39;stu-D&#39;}
</code></pre>
</li>
<li><p>ZSet: 有序集合(set的升级), 每次添加修改元素后会自动重新排序,<code>n1 -&gt; {(value1,score1),(value2,score2),...}</code></p>
<pre><code class="lang-python">  # 每一个元素有两个值，值value和分数score(专门用来做排序)
  # 元素rank(表index，即下标索引)
  # lexicographical: 相同的分值时，有序集合的元素会根据成员的值逐字节对比

  # zadd(name, mapping, nx=False, xx=False, ch=False, incr=False) 添加

  # zrem(name, values)                                            删除
  # zremrangebyrank(name, start, end)
  # zremrangebyscore(name, minscore, maxscore)

  # zscan(name, cursor=0, match=None, count=None, score_cast_func=float) 查看
  # zscan_iter(name, match=None, count=None,score_cast_func=float)

  # zrange/zrevrange(name, start, end, desc=False, withscores=False, score_cast_func=float) 获取rank范围内的元素
  # zrangebyscore(name,minscore,maxscore,...)   获取score范围内的元素

  # zrank/zrevrank(name, value)                  获取元素rank
  # zscore(name, value)                          获取元素score

  # zcard(name)                         所有元素个数
  # zcount(name, minscore, maxscore)    指定score范围内的元素数量

  # zincrby(name, value, amount)                自增
  # zinterstore(dest, keys, aggregate=None)     交集(相同值不同分数，则按照 aggregate=SUM/MIN/MAX 进行操作)
  # zunionstore(dest, keys, aggregate=None)     并集

  def test_zset():
      print(&quot;Test ZSet:&quot;)

      # 创建
      result = client.zadd(&#39;car1&#39;,{&#39;car-A&#39;:10,&#39;car-B&#39;:20,&#39;car-C&#39;:30,&#39;car-D&#39;:40}) 
      print(result)                    # 4

      # 列出
      result = client.zscan(&#39;car1&#39;)
      print(result)                   # (0, [(b&#39;car-A&#39;, 10.0), (b&#39;car-B&#39;, 20.0), (b&#39;car-C&#39;, 30.0), (b&#39;car-D&#39;, 40.0)])

      # 切片，获取元素列表
      result = client.zrange(&#39;car1&#39;,1,3)
      print(result)                   # [b&#39;car-B&#39;, b&#39;car-C&#39;, b&#39;car-D&#39;]
      result = client.zrangebyscore(&#39;car1&#39;,15,35)
      print(result)                   # [b&#39;car-B&#39;, b&#39;car-C&#39;]

      # 统计数量
      result = client.zcard(&#39;car1&#39;)
      print(result)                   # 4
      result = client.zcount(&#39;car1&#39;,15,35)
      print(result)                   # 2

      # 获取元素属性：rank,score
      result = client.zrank(&#39;car1&#39;,&#39;car-C&#39;)
      print(result)                   # 2
      result = client.zscore(&#39;car1&#39;,&#39;car-C&#39;)
      print(result)                   # 30.0

      # 交集
      result = client.zadd(&#39;car2&#39;,{&#39;car-B&#39;:25,&#39;car-D&#39;:45,&#39;car-E&#39;:55})
      print(result)                   # 3

      result = client.zinterstore(&#39;car-inter&#39;,(&#39;car1&#39;,&#39;car2&#39;))
      print(result)                   # 2
      result = client.zscan(&#39;car-inter&#39;)
      print(result)                   # (0, [(b&#39;car-B&#39;, 45.0), (b&#39;car-D&#39;, 85.0)])

      result = client.zinterstore(&#39;car-inter&#39;,(&#39;car1&#39;,&#39;car2&#39;),aggregate=&#39;MAX&#39;)
      print(result)                   # 2
      result = client.zscan(&#39;car-inter&#39;)
      print(result)                   # (0, [(b&#39;car-B&#39;, 25.0), (b&#39;car-D&#39;, 45.0)])
</code></pre>
</li>
</ul>
</li>
<li><p>其他常用操作</p>
<pre><code class="lang-python"> # flushdb(asynchronous=False)
 # flushall(asynchronous=False)
 # delete( *names)
 # exists( name)
 # keys( pattern=&#39;*&#39;)
 # expire(name ,time)
 # rename( src, dst)
 # move( name, db)
 # randomkey()
 # type(name)

 def test_others():
     result = client.keys()
     print(result)
     # [b&#39;car-inter&#39;, b&#39;car1&#39;, b&#39;car2&#39;, b&#39;car&#39;, b&#39;stdGrp1&#39;, b&#39;stdGrp2&#39;, b&#39;stu-001&#39;, b&#39;a&#39;, b&#39;top:dupefilter&#39;, b&#39;stu-002&#39;, b&#39;top:items&#39;, b&#39;group1&#39;, b&#39;tt&#39;]

     result = client.delete(&#39;car&#39;)
     print(result)       # 1

     result = client.exists(&#39;car&#39;)
     print(result)       # 0

     result = client.type(&#39;car-inter&#39;)
     print(result)       # b&#39;zset&#39;
</code></pre>
</li>
<li><p>管道: 批量提交命令,还可用来实现事务transation</p>
<pre><code class="lang-python"> # pipeline(transaction=True,shard_hint=None) 默认情况下一次pipline是原子性操作
 # pipe.watch(name) -- 乐观锁，watch的对象不可改
 # pipe.unwatch()

 def test_pipeline():
     import time

     client.set(&#39;cnt&#39;,10)
     result=client.get(&#39;cnt&#39;)
     print(&#39;initial cnt:&#39;,result)

     pipe=client.pipeline(transaction=True)
     pipe.watch(&#39;cnt&#39;)               # 加锁
     try:
         pipe.multi()

         cnt=int(client.get(&#39;cnt&#39;))
         pipe.set(&#39;a&#39;, 1)
         pipe.set(&#39;cnt&#39;,cnt+1)
         pipe.set(&#39;b&#39;,2)

         print(&#39;sleep...&#39;)
         time.sleep(5)               # 此时，若另一个客户端修改了cnt，则这段操作提交（执行execute）时会报错

         print(&#39;execute...&#39;)
         pipe.execute()
     except redis.exceptions.WatchError as ex:
         print(&quot;pipe fail:&quot;,ex)
     else:
         print(&quot;pipe success&quot;)
     finally:
         print(&quot;finally: a=%s,cnt=%s,b=%s&quot; % (client.get(&#39;a&#39;),client.get(&#39;cnt&#39;),client.get(&#39;b&#39;)))
         pipe.unwatch()              # 解锁
</code></pre>
</li>
<li><p>发布／订阅 －－ 不推荐使用</p>
<pre><code class="lang-python"> # 发布： 
 #   publish(channel,msg)     
 #   =&gt; redis client execute : `publish channel msg` 
 # 订阅： 
 #   pubsub().subscribe(channel).parse_response(block,timeout)  
 #   =&gt; redis client execute : `subscribe channel` (取消使用命令punsubscribe/unsubscribe)
 def test_publish():
     result=client.publish(&quot;channel-1&quot;,&quot;Hello!&quot;)
     print(&quot;result:&quot;,result)     # 0

     while True:
         msg = &quot;This is %.2f&quot; % (random.random()*10)
         print(&#39;sending...&#39;,msg)

         result=client.publish(&quot;channel-1&quot;,msg)
         if result==1:
             print(&#39;send success&#39;)
         else:
             print(&#39;send fail&#39;)

         isCondinue=input(&quot;continue?(y/n)&quot;)
         if isCondinue==&#39;n&#39;:
             break;

     print(&#39;Done!&#39;)

 def test_subscribe():
     subscribeObj = client.pubsub()
     result=subscribeObj.subscribe(&quot;channel-1&quot;)
     print(result)           # None

     while True:
         print(&#39;receiving...&#39;)
         msg=subscribeObj.parse_response(block=False,timeout=60)
         # 第一次收到：[b&#39;subscribe&#39;, b&#39;channel-1&#39;, 1]
         # 当另一个客户端向此channel发布消息时（eg: `publish channel-1 &quot;Hello World&quot;`）
         # 这里会收到： [b&#39;message&#39;, b&#39;channel-1&#39;, b&#39;Hello World&#39;]
         print(&quot;receive msg:&quot;,msg)   
         isCondinue=input(&quot;continue?(y/n)&quot;)
         if isCondinue==&#39;n&#39;:
             break;
     print(&quot;Done!&quot;)

 if __name__==&#39;__main__&#39;:
     # test_publish()
     # test_subscribe()
</code></pre>
</li>
</ol>
<h3 id="header-63">MongoDB</h3>
<p><code>pip install pymongo</code></p>
<pre><code class="lang-python">import pymongo
import json
from datetime import datetime

# 1. 建立连接
mongoConnStr=&quot;mongodb://cj:123456@localhost:27017/?authSource=admin&quot;
client=pymongo.MongoClient(mongoConnStr)    
print(&quot;list dbs:&quot;,client.list_database_names())                         # 列出dbs

db=client[&#39;mg_test&#39;]
print(&quot;list collections of mg_test db:&quot;,db.list_collection_names())     # 列出collections(类似表)

collection=db[&#39;movies&#39;]
print(&quot;get collection:movies count:&quot;,collection.estimated_document_count())

# 2. clear:
# ret=collection.delete_many({})           
# print(ret.deleted_count,ret.acknowledged,ret.raw_result)

# 3. update_one -- update or insert record
contents=json.load(open(&#39;test.json&#39;,&#39;r&#39;))           # load: file -&gt; string -&gt; python obj

print(&#39;update or insert records:&#39;)
for record in contents:
    id=record.pop(&#39;id&#39;)
    t=datetime.now()
    print(&quot;to store record...id=%s,title=%s&quot; % (id,record[&#39;title&#39;]))

    record[&#39;last_update_time&#39;]=t
    ret=collection.update_one({&#39;_id&#39;:id}
            ,{&#39;$setOnInsert&#39;:{&#39;create_time&#39;:t},&#39;$set&#39;:record}
            ,upsert=True)

    print(ret.matched_count,ret.modified_count,ret.upserted_id,ret.acknowledged,ret.raw_result)

# 4. find -- list records
print(&#39;list stored records:&#39;)

results=collection.find({},{&#39;_id&#39;:1,&#39;title&#39;:1,&#39;rate&#39;:1})
for result in results:
    print(result)
# results sample:
# {&#39;_id&#39;: &#39;27109879&#39;, &#39;rate&#39;: &#39;6.5&#39;, &#39;title&#39;: &#39;硬核&#39;}
# {&#39;_id&#39;: &#39;26707088&#39;, &#39;rate&#39;: &#39;7.1&#39;, &#39;title&#39;: &#39;奎迪：英雄再起&#39;}
# {&#39;_id&#39;: &#39;30334122&#39;, &#39;rate&#39;: &#39;6.1&#39;, &#39;title&#39;: &#39;芳龄十六&#39;}
# {&#39;_id&#39;: &#39;1945750&#39;, &#39;rate&#39;: &#39;7.7&#39;, &#39;title&#39;: &#39;污垢&#39;}
# {&#39;_id&#39;: &#39;26611891&#39;, &#39;rate&#39;: &#39;6.8&#39;, &#39;title&#39;: &#39;欢乐满人间2&#39;}

print(&#39;list rate&gt;=7 records:&#39;)
results=collection.find({&#39;rate&#39;:{&#39;$gte&#39;:&quot;7&quot;}},{&#39;_id&#39;:1,&#39;title&#39;:1,&#39;rate&#39;:1}).limit(5)
for record in results:
    print(record)

# results sample:
# {&#39;_id&#39;: &#39;26707088&#39;, &#39;rate&#39;: &#39;7.1&#39;, &#39;title&#39;: &#39;奎迪：英雄再起&#39;}
# {&#39;_id&#39;: &#39;1945750&#39;, &#39;rate&#39;: &#39;7.7&#39;, &#39;title&#39;: &#39;污垢&#39;}

# 5. aggregate -- summary records
print(&#39;list summary by rate level&#39;)
# $cond:{if:{$gte:[&#39;$rating&#39;,8]},then:1,else:0} 
# $addFields:{&#39;rate_number&#39;:{$convert:{input:&quot;$rate&quot;,to:&quot;int&quot;}}} 
# use $project also could add fields
results=collection.aggregate([
    {&#39;$addFields&#39;:{
        &#39;rate_number&#39;:{&#39;$convert&#39;:{&#39;input&#39;:&quot;$rate&quot;,&#39;to&#39;:&quot;double&quot;}}
        ,&#39;rate_level&#39;:{&#39;$cond&#39;:[
            {&#39;$lt&#39;:[&#39;$rate&#39;,&#39;7.5&#39;]}
            ,{&#39;$cond&#39;:[{&#39;$gte&#39;:[&#39;$rate&#39;,&#39;6.5&#39;]},&#39;Middle&#39;,&#39;Low&#39;]}
            ,&#39;High&#39;
        ]}
    }}
    # ,{&#39;$project&#39;:{
    #     &#39;_id&#39;:1
    #     ,&#39;rate&#39;:1
    #     ,&#39;title&#39;:1
    #     # ,&#39;rate_level&#39;:{&#39;$cond&#39;:[
    #     #     {&#39;$lt&#39;:[&#39;$rate&#39;,&#39;7.5&#39;]}
    #     #     ,{&#39;$cond&#39;:[{&#39;$gte&#39;:[&#39;$rate&#39;,&#39;6.5&#39;]},&#39;Middle&#39;,&#39;Low&#39;]}
    #     #     ,&#39;High&#39;
    #     # ]}
    # }}
    ,{&#39;$group&#39;:{
        &#39;_id&#39;:&quot;$rate_level&quot;
        ,&#39;count&#39;:{&#39;$sum&#39;:1}
        ,&#39;avg_rate&#39;:{&#39;$avg&#39;:&#39;$rate_number&#39;}
        #,&#39;rate_list&#39;:{&#39;$push&#39;:&#39;$rate_number&#39;}
        ,&#39;rate_list&#39;:{&#39;$push&#39;:{&#39;$concat&#39;:[&#39;$title&#39;,&#39;:&#39;,&#39;$rate&#39;]}}
    }}
    ,{&#39;$sort&#39;:{&#39;count&#39;:-1}}
    #,{&#39;$limit&#39;:10}
])
for record in results:
    print(record)

# results sample:
# {&#39;_id&#39;: &#39;Middle&#39;, &#39;count&#39;: 3, &#39;avg_rate&#39;: 6.8, &#39;rate_list&#39;: [&#39;硬核:6.5&#39;, &#39;奎迪：英雄再起:7.1&#39;, &#39;欢乐满人间2:6.8&#39;]}
# {&#39;_id&#39;: &#39;Low&#39;, &#39;count&#39;: 1, &#39;avg_rate&#39;: 6.1, &#39;rate_list&#39;: [&#39;芳龄十六:6.1&#39;]}
# {&#39;_id&#39;: &#39;High&#39;, &#39;count&#39;: 1, &#39;avg_rate&#39;: 7.7, &#39;rate_list&#39;: [&#39;污垢:7.7&#39;]}


print(&quot;Done!&quot;)
</code></pre>
<h2 id="header-64">Reference</h2>
<ul>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Python3-cookbook</a></li>
<li><a href="https://docs.python.org/zh-cn/3/library/index.html" target="_blank" rel="noopener">Python 标准库</a></li>
<li><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html?highlight=coroutine#" target="_blank" rel="noopener">Python 标准库:协程与任务</a></li>
<li><a href="https://dev.to/welldone2094/async-programming-in-python-with-asyncio-12dl" target="_blank" rel="noopener">Async programming in Python with asyncio</a></li>
<li><a href="https://www.datacamp.com/community/tutorials/asyncio-introduction" target="_blank" rel="noopener">Asyncio: An Introduction</a></li>
<li><a href="https://stackabuse.com/python-async-await-tutorial/" target="_blank" rel="noopener">Python async/await Tutorial</a></li>
<li><a href="https://python-parallel-programmning-cookbook.readthedocs.io/zh_CN/latest/chapter4/index.html" target="_blank" rel="noopener">python parallel programmning cookbook: 第四章 异步编程</a></li>
<li><a href="https://my.oschina.net/lionets/blog/189326" target="_blank" rel="noopener">Python定制类的特殊方法与授权</a></li>
<li><a href="http://zhuoqiang.me/python-thread-gil-and-ctypes.html" target="_blank" rel="noopener">CPython GIL</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python教程-廖雪峰</a></li>
<li><a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python-100天从新手到大师</a></li>
<li><a href="https://www.hongweipeng.com/index.php/series.html" target="_blank" rel="noopener">Python源码阅读</a></li>
</ul>
  </section>
</article>

      <hr/>
      
<section class="post-comment">
	
		<div id="gitment_container"></div>

<link rel="stylesheet" href="/gitment/default.css">
<script src="/gitment/gitment.browser.js"></script>


<script type="text/javascript">
	var gitment = new Gitment({
	  id: document.location.pathname,
	  owner: 'chenjin-zero',
	  repo: 'blogComment',
	  oauth: {
	    client_id: '36a09bb7399efe69c6ce',
	    client_secret: 'ad9ad546b23b708c71d92e513dc36e0486179dea',
	  }
	})
      
	gitment.render('gitment_container')
</script>
	
</section>

    </div>
  </div>
</body>

<script src="/jquery/dist/jquery.min.js"></script>
<script src="/bootstrap/dist/js/bootstrap.min.js"></script>


	<script src="/highlight/highlight.pack.js"></script>
	<script type="text/javascript">
		hljs.initHighlightingOnLoad();
	</script>



<script type="text/javascript">

  $(document).ready(function(){
    var sidebarCtrl=$("#sidebar-ctrl");
    var sidebar=$("#sidebar");
    var wrapper=$("#wrapper");
    sidebarCtrl.on("click",function(event){
        //alert("click");
        sidebar.toggleClass("sidebar-toggle");
        wrapper.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("sidebar-toggle");
        sidebarCtrl.toggleClass("active");
    })
  });
</script>


</html>
